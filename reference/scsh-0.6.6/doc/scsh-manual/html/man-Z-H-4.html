<!doctype html public "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!--

Generated from TeX source by tex2page, v 4r8f
(running on MzScheme 204, unix), 
(c) Dorai Sitaram, 
http://www.ccs.neu.edu/~dorai/tex2page/tex2page-doc.html

-->
<head>
<title>
Scsh Reference Manual
</title>
<link rel="stylesheet" type="text/css" href="man-Z-S.css" title=default>
<meta name=robots content="noindex,follow">
</head>
<body>
<div align=right class=navigation><i>[Go to <span><a href="man.html">first</a>, <a href="man-Z-H-3.html">previous</a></span><span>, <a href="man-Z-H-5.html">next</a></span> page<span>; &nbsp;&nbsp;</span><span><a href="man-Z-H-1.html#node_toc_start">contents</a></span><span><span>; &nbsp;&nbsp;</span><a href="man-Z-H-13.html#node_index_start">index</a></span>]</i></div><p></p>
<a name="node_chap_3"></a>
<h1 class=chapter>
<div class=chapterheading><a href="man-Z-H-1.html#node_toc_node_chap_3">Chapter 3</a></div><br>
<a href="man-Z-H-1.html#node_toc_node_chap_3">System Calls</a></h1><p></p>
<p>
Scsh provides (almost) complete access to the basic Unix kernel services:
processes, files, signals and so forth.  These procedures comprise a 
Scheme binding for P<small>O</small><small>S</small><small>I</small><small>X</small>, with a few of the more standard extensions
thrown in (<em>e.g.</em>, symbolic links, <tt>fchown</tt>, <tt>fstat</tt>, sockets).</p>
<p>
</p>
<a name="node_sec_3.1"></a>
<h2><a href="man-Z-H-1.html#node_toc_node_sec_3.1">3.1&nbsp;&nbsp;Errors</a></h2><p>Scsh syscalls never return error codes, and do not use a global
<tt>errno</tt> variable to report errors.
Errors are consistently reported by raising exceptions.
This frees up the procedures to return useful values,
and allows the programmer to assume that 
<em>if a syscall returns, it succeeded.</em>
This greatly simplifies the flow of the code from the programmer's point
of view.</p>
<p>
Since Scheme does not yet have a standard exception system, the scsh
definition remains somewhat vague on the actual form of exceptions
and exception handlers. When a standard exception system is defined,
scsh will move to it. For now, scsh uses the Scheme 48 exception system,
with a simple sugaring on top to hide the details in the common case.</p>
<p>
System call error exceptions contain the Unix <tt>errno</tt> code reported by
the system call. Unlike C, the <tt>errno</tt> value is a part of the exception
packet, it is <em>not</em> accessed through a global variable.</p>
<p>
For reference purposes, the Unix <tt>errno</tt> numbers 
are bound to the variables <tt>errno/perm</tt>, <tt>errno/noent</tt>, <em>etc.</em>
System calls never return <tt>error/intr</tt> -- they
automatically retry.</p>
<p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_68"></a><div align=left><tt>(errno-error <i>errno syscall . data</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>no return value</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Raises a Unix error exception for Unix error number <i>errno</i>.
The <i>syscall</i> and <i>data</i> arguments are packaged up in the exception
packet passed to the exception handler.
</blockquote><p>
<a name="node_idx_70"></a></p>
<div align=left><tt>(with-errno-handler* <i>handler thunk</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>value(s) of thunk</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_72"></a><div align=left><tt>(with-errno-handler <i>handler-spec . body</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>value&nbsp;of&nbsp;body</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax)&nbsp;</div>
<blockquote>
Unix syscalls raise error exceptions by calling <tt>errno-error</tt>.
Programs can use <tt>with-errno-handler*</tt> to establish
handlers for these exceptions.<p>
If a Unix error arises while <i>thunk</i> is executing, 
<i>handler</i> is called on two arguments like this:
</p>
<blockquote><tt>(<i>handler</i> <i>errno</i> <i>packet</i>)</tt></blockquote><i>packet</i> is a list of the form
<div align=center><table><tr><td><i>packet</i>  =  <tt>(<i>errno-msg</i> <i>syscall</i> . <i>data</i>)</tt>,</td></tr></table></div><p>
where <i>errno-msg</i> is the standard Unix error message for the error,
<i>syscall</i> is the procedure that generated the error,
and   <i>data</i> is a list of information generated by the error,
which varies from syscall to syscall.</p>
<p>
If <i>handler</i> returns, the handler search continues upwards.
<i>Handler</i> can acquire the exception by invoking a saved continuation.
This procedure can be sugared over with the following syntax:
</p>
<blockquote><tt><br>
(with-errno-handler<br>
&nbsp;&nbsp;&nbsp;&nbsp;((<i>errno</i>&nbsp;<i>packet</i>)&nbsp;<i>clause</i>&nbsp;<tt>...</tt>)<br>
&nbsp;&nbsp;<i>body1</i><br>
&nbsp;&nbsp;<i>body2</i><br>
&nbsp;&nbsp;<tt>...</tt>)</tt></blockquote>
This form executes the body forms with a particular errno handler installed.
When an errno error is raised, the handler search machinery will
bind variable <i>errno</i> to the error's integer code, and variable
<i>packet</i> to the error's auxiliary data packet.
Then, the clauses will be checked for a match.
The first clause that matches is executed, and its value is the
value of the entire <tt>with-errno-handler</tt> form.
If no clause matches, the handler search continues.<p>
Error clauses have two forms
</p>
<blockquote><tt><br>
((<i>errno</i>&nbsp;<tt>...</tt>)&nbsp;<i>body</i>&nbsp;<tt>...</tt>)<br>
(else&nbsp;<i>body</i>&nbsp;<tt>...</tt>)</tt></blockquote>
In the first type of clause, the <i>errno</i> forms are integer expressions.
They are evaluated and compared to the error's errno value.
An <tt>else</tt> clause matches any errno value. 
Note that the <i>errno</i> and <i>data</i>
variables are lexically visible to the error clauses.<p>
Example:
</p>
<blockquote><tt>&nbsp;&nbsp;&nbsp;<br>
(with-errno-handler&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;((errno&nbsp;packet)&nbsp;;&nbsp;Only&nbsp;handle&nbsp;3&nbsp;particular&nbsp;errors.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((errno/wouldblock&nbsp;errno/again)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(loop))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((errno/acces)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(format&nbsp;#t&nbsp;&quot;Not&nbsp;allowed&nbsp;access!&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#f))<br>
<br>
&nbsp;&nbsp;(foo&nbsp;frobbotz)<br>
&nbsp;&nbsp;(blatz&nbsp;garglemumph))</tt></blockquote>
It is not defined what dynamic context the handler executes in,
so fluid variables cannot reliably be referenced.<p>
Note that Scsh system calls always retry when interrupted, so that
the <tt>errno/intr</tt> exception is never raised.
If the programmer wishes to abort a system call on an interrupt, he
should have the interrupt handler explicitly raise an exception or
invoke a stored continuation to throw out of the system call.
</p>
</blockquote><p>
</p>
<a name="node_sec_3.1.1"></a>
<h3><a href="man-Z-H-1.html#node_toc_node_sec_3.1.1">3.1.1&nbsp;&nbsp;Interactive mode and error handling</a></h3><p>Scsh runs in two modes: interactive and script mode. It starts up in
interactive mode if the scsh interpreter is started up with no script
argument. Otherwise, scsh starts up in script mode.  The mode determines
whether scsh prints prompts in between reading and evaluating forms, and it
affects the default error handler.  In interactive mode, the default error
handler will report the error, and generate an interactive breakpoint so that
the user can interact with the system to examine, fix, or dismiss from the
error. In script mode, the default error handler causes the scsh process to
exit.</p>
<p>
When scsh forks a child with <tt>(fork)</tt>, the child resets to script mode.
This can be overridden if the programmer wishes.</p>
<p>
</p>
<a name="node_sec_3.2"></a>
<h2><a href="man-Z-H-1.html#node_toc_node_sec_3.2">3.2&nbsp;&nbsp;I/O</a></h2><p></p>
<a name="node_sec_3.2.1"></a>
<h3><a href="man-Z-H-1.html#node_toc_node_sec_3.2.1">3.2.1&nbsp;&nbsp;Standard R5RS I/O procedures</a></h3><p>In scsh, most standard R5RS I/O operations (such as <tt>display</tt> or
<tt>read-char</tt>) work on both integer file descriptors and Scheme ports.
When doing I/O with a file descriptor, the I/O operation is done
directly on the file, bypassing any buffered data that may have
accumulated in an associated port.
Note that character-at-a-time operations such as <tt>read-char</tt>
are likely to be quite slow when performed directly upon file
descriptors.</p>
<p>
The standard R5RS procedures <tt>read-char</tt>, <tt>char-ready?</tt>, <tt>write</tt>,
<tt>display</tt>, <tt>newline</tt>,
and <tt>write-char</tt> are all generic, accepting integer file descriptor
arguments as well as ports.
Scsh also mandates the availability of <tt>format</tt>, and further requires
<tt>format</tt> to accept file descriptor arguments as well as ports.</p>
<p>
The procedures <tt>peek-char</tt> and <tt>read</tt> do <em>not</em> accept
file descriptor arguments, since these functions require the ability to
read ahead in the input stream, a feature not supported by Unix I/O.</p>
<p>
</p>
<a name="node_sec_3.2.2"></a>
<h3><a href="man-Z-H-1.html#node_toc_node_sec_3.2.2">3.2.2&nbsp;&nbsp;Port manipulation and standard ports</a></h3><p></p>
<p></p>
<p></p>
<p><a name="node_idx_74"></a></p>
<div align=left><tt>(close-after <i>port consumer</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>value(s) of consumer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Returns <tt>(<i>consumer</i> <i>port</i>)</tt>, but closes the port on return.
No dynamic-wind magic. <blockquote><i>Remark: </i> Is there a less-awkward name?</blockquote>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_76"></a></p>
<div align=left><tt>(error-output-port<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>port</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
This procedure is analogous to <tt>current-output-port</tt>, but produces
a port used for error messages -- the scsh equivalent of stderr.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_78"></a></p>
<div align=left><tt>(with-current-input-port* <i>port thunk</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>value(s) of thunk</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_80"></a><div align=left><tt>(with-current-output-port* <i>port thunk</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>value(s) of thunk</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_82"></a><div align=left><tt>(with-error-output-port* <i>port thunk</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>value(s) of thunk</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
These procedures install <i>port</i> as the current input, current output,
and error output port, respectively, for the duration of a call to
<i>thunk</i>.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_84"></a></p>
<div align=left><tt>(with-current-input-port <i>port . body</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>value(s) of body</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax)&nbsp;</div>

<a name="node_idx_86"></a><div align=left><tt>(with-current-output-port <i>port . body</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>value(s) of body</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax)&nbsp;</div>

<a name="node_idx_88"></a><div align=left><tt>(with-error-output-port <i>port . body</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>value(s) of body</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax)&nbsp;</div>

<blockquote>
These special forms are simply syntactic sugar for the
<tt>with-current-input-port*</tt> procedure and friends.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_90"></a></p>
<div align=left><tt>(set-current-input-port! <i>port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_92"></a><div align=left><tt>(set-current-output-port! <i>port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_94"></a><div align=left><tt>(set-error-output-port! <i>port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
These procedures alter the dynamic binding of the current I/O port procedures
to new values.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_96"></a></p>
<div align=left><tt>(close <i>fd/port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Close the port or file descriptor.<p>
If <i>fd/port</i> is a file descriptor, and it has a port allocated to it,
the port is shifted to a new file descriptor created with <tt>(dup
fd/port)</tt> before closing <tt>fd/port</tt>. The port then has its revealed
count set to zero.  This reflects the design criteria that ports are not
associated with file descriptors, but with open files.</p>
<p>
To close a file descriptor, and any associated port it might have, you
must instead say one of (as appropriate):
</p>
<blockquote><tt><br>
(close&nbsp;(fdes-&gt;inport&nbsp;&nbsp;fd))<br>
(close&nbsp;(fdes-&gt;outport&nbsp;fd))</tt></blockquote><p>
The procedure returns true if it closed an open port.
If the port was already closed, it returns false; 
this is not an error.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_98"></a></p>
<div align=left><tt>(stdports-&gt;stdio<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_100"></a><div align=left><tt>(stdio-&gt;stdports<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
These two procedures are used to synchronise Unix' standard I/O
file descriptors and Scheme's current I/O ports.<p>
<tt>(stdports-&gt;stdio)</tt> causes the standard I/O file descriptors
(0, 1, and 2) to take their values from the current I/O ports.
It is exactly equivalent to the series of 
redirections:<a name="call_footnote_Temp_4"></a><a href="#footnote_Temp_4"><sup><small>3</small></sup></a>
</p>
<blockquote><tt><br>
(dup&nbsp;(current-input-port)&nbsp;&nbsp;0)<br>
(dup&nbsp;(current-output-port)&nbsp;1)<br>
(dup&nbsp;(error-output-port)&nbsp;&nbsp;&nbsp;2)</tt></blockquote>
<tt>stdio-&gt;stdports</tt> causes the bindings of the current I/O ports
to be changed to ports constructed over the standard I/O file
descriptors.
It is exactly equivalent to the series of assignments
<blockquote><tt><br>
(set-current-input-port!&nbsp;&nbsp;(fdes-&gt;inport&nbsp;&nbsp;0))<br>
(set-current-output-port!&nbsp;(fdes-&gt;outport&nbsp;1))<br>
(set-error-output-port!&nbsp;&nbsp;&nbsp;(fdes-&gt;outport&nbsp;2))</tt></blockquote>
However, you are more likely to find the dynamic-extent variant,
<tt>with-stdio-ports*</tt>, below, to be of use in general programming.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_102"></a></p>
<div align=left><tt>(with-stdio-ports* <i>thunk</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>value(s) of thunk</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_104"></a><div align=left><tt>(with-stdio-ports <i>body <tt>...</tt></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>value(s) of body</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax)&nbsp;</div>

<blockquote>
<tt>with-stdio-ports*</tt> binds the standard ports <tt>(current-input-port)</tt>, 
<tt>(current-output-port)</tt>, and <tt>(error-output-port)</tt> to be ports
on file descriptors 0, 1, 2, and then calls <i>thunk</i>.
It is equivalent to:
<blockquote><tt><br>
(with-current-input-port&nbsp;(fdes-&gt;inport&nbsp;0)<br>
&nbsp;&nbsp;(with-current-output-port&nbsp;(fdes-&gt;inport&nbsp;1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;(with-error-output-port&nbsp;(fdes-&gt;outport&nbsp;2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(thunk))))</tt></blockquote>
The <tt>with-stdio-ports</tt> special form is merely syntactic sugar.
</blockquote><p>
</p>
<a name="node_sec_3.2.3"></a>
<h3><a href="man-Z-H-1.html#node_toc_node_sec_3.2.3">3.2.3&nbsp;&nbsp;String ports</a></h3><p>Scheme 48 has string ports, which you can use. Scsh has not committed to the
particular interface or names that Scheme 48 uses, so be warned that the
interface described herein may be liable to change.</p>
<p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_106"></a></p>
<div align=left><tt>(make-string-input-port <i>string</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>port</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Returns a port that reads characters from the supplied string.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_108"></a></p>
<div align=left><tt>(make-string-output-port<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>port</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_110"></a><div align=left><tt>(string-output-port-output <i>port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
A string output port is a port that collects the characters given to it into
a string.
The accumulated string is retrieved by applying <tt>string-output-port-output</tt>
to the port.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_112"></a></p>
<div align=left><tt>(call-with-string-output-port <i>procedure</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
The <i>procedure</i> value is called on a port.  When it returns, 
<tt>call-with-string-output-port</tt> returns a string containing the 
characters that were written to that port during the execution
of <i>procedure</i>.
</blockquote><p>
</p>
<a name="node_sec_3.2.4"></a>
<h3><a href="man-Z-H-1.html#node_toc_node_sec_3.2.4">3.2.4&nbsp;&nbsp;Revealed ports and file descriptors</a></h3><p>The material in this section and the following one is not critical for most
applications.
You may safely skim or completely skip this section on a first reading.</p>
<p>
Dealing with Unix file descriptors in a Scheme environment is difficult. 
In Unix, open files are part of the process environment, and are referenced
by small integers called <em>file descriptors</em>. Open file descriptors are
the fundamental way I/O redirections are passed to subprocesses, since
file descriptors are preserved across fork's and exec's.</p>
<p>
Scheme, on the other hand, uses ports for specifying I/O sources. Ports are
garbage-collected Scheme objects, not integers. Ports can be garbage
collected; when a port is collected, it is also closed. Because file
descriptors are just integers, it's impossible to garbage collect them -- you
wouldn't be able to close file descriptor 3 unless there were no 3's in the
system, and you could further prove that your program would never again
compute a 3. This is difficult at best.</p>
<p>
If a Scheme program only used Scheme ports, and never actually used
file descriptors, this would not be a problem. But Scheme code
must descend to the file descriptor level in at least two circumstances:
</p>
<ul>    
<li><p>when interfacing to foreign code
</p>
<li><p>when interfacing to a subprocess.
</p>
</ul><p>
This causes a problem. Suppose we have a Scheme port constructed
on top of file descriptor 2. We intend to fork off a program that
will inherit this file descriptor. If we drop references to the port,
the garbage collector may prematurely close file 2 before we fork
the subprocess. The interface described below is intended to fix this and 
other problems arising from the mismatch between ports and file descriptors.</p>
<p>
The Scheme kernel maintains a port table that maps a file descriptor
to the Scheme port allocated for it (or, <tt>#f</tt> if there is no port
allocated for this file descriptor). This is used to ensure that
there is at most one open port for each open file descriptor.</p>
<p>
The port data structure for file ports has two fields besides the descriptor:
<i>revealed</i> and <i>closed?</i>. 
When a file port is closed with <tt>(close port)</tt>, 
the port's file descriptor is closed, its entry in the port table is cleared, 
and the port's <i>closed?</i> field is set to true. </p>
<p>
When a file descriptor is closed with <tt>(close fdes)</tt>, any associated
port is shifted to a new file descriptor created with <tt>(dup fdes)</tt>.
The port has its revealed count reset to zero (and hence becomes eligible
for closing on GC). See discussion below.
To really put a stake through a descriptor's heart without waiting for
associated ports to be GC'd, you must say one of
</p>
<blockquote><tt><br>
(close&nbsp;(fdes-&gt;inport&nbsp;fdes))<br>
(close&nbsp;(fdes-&gt;output&nbsp;fdes))</tt></blockquote><p>
The <i>revealed</i> field is an aid to garbage collection. It is an integer
semaphore. If it is zero, the port's file descriptor can be closed when
the port is collected. Essentially, the <i>revealed</i> field reflects whether
or not the port's file descriptor has escaped to the Scheme user. If
the Scheme user doesn't know what file descriptor is associated with
a given port, then he can't possibly retain an ``integer handle'' on the
port after dropping pointers to the port itself, so the garbage collector
is free to close the file.</p>
<p>
Ports allocated with <tt>open-output-file</tt> and <tt>open-input-file</tt> are
unrevealed ports -- <em>i.e.</em>, <i>revealed</i> is initialised to 0.
No one knows the port's file descriptor, so the file descriptor can be closed
when the port is collected.</p>
<p>
The functions <tt>fdes-&gt;output-port</tt>, <tt>fdes-&gt;input-port</tt>, <tt>port-&gt;fdes</tt>
are used to shift back and forth between file descriptors and ports.  When
<tt>port-&gt;fdes</tt> reveals a port's file descriptor, it increments the port's
<i>revealed</i> field.  When the user is through with the file descriptor, he
can call <tt>(release-port-handle <i>port</i>)</tt>, which decrements the count. 
The function <tt>(call/fdes fd/port <i>proc</i>)</tt> automates this protocol.
<tt>call/fdes</tt> uses <tt>dynamic-wind</tt> to enforce the protocol.  
If <i>proc</i> throws out of the <tt>call/fdes</tt> application,
the unwind handler releases the descriptor handle;
if the user subsequently tries to throw <em>back</em> into <i>proc</i>'s
context, the wind handler raises an error. When the user maps a file
descriptor to a port with <tt>fdes-&gt;outport</tt> or <tt>fdes-&gt;inport</tt>, the port
has its revealed field incremented.</p>
<p>
Not all file descriptors are created by requests to make ports.  Some are
inherited on process invocation via <tt><a href="http://www.FreeBSD.org/cgi/man.cgi?query=exec&apropos=0&sektion=0&manpath=FreeBSD+4.3-RELEASE&format=html">exec(2)</a></tt>, and are simply part of the
global environment. Subprocesses may depend upon them, so if a port is later
allocated for these file descriptors, is should be considered as a revealed
port. For example, when the Scheme shell's process starts up, it opens ports
on file descriptors 0, 1, and 2 for the initial values of
<tt>(current-input-port)</tt>, <tt>(current-output-port)</tt>, and
<tt>(error-output-port)</tt>. 
These ports are initialised with <i>revealed</i> set to 1,
so that stdin, stdout, and stderr are not closed even if the user drops the
port.  </p>
<p>
Unrevealed file ports have the nice property that they can be closed when all
pointers to the port are dropped. This can happen during gc, or at an
<tt><a href="http://www.FreeBSD.org/cgi/man.cgi?query=exec&apropos=0&sektion=0&manpath=FreeBSD+4.3-RELEASE&format=html">exec()</a></tt> -- since all memory is dropped at an <tt><a href="http://www.FreeBSD.org/cgi/man.cgi?query=exec&apropos=0&sektion=0&manpath=FreeBSD+4.3-RELEASE&format=html">exec()</a></tt>.  No one knows the
file descriptor associated with the port, so the exec'd process certainly
can't refer to it.</p>
<p>
This facility preserves the transparent close-on-collect property
for file ports that are used in straightforward ways, yet allows
access to the underlying Unix substrate without interference from
the garbage collector. This is critical, since shell programming
absolutely requires access to the Unix file descriptors, as their
numerical values are a critical part of the process interface.</p>
<p>
A port's underlying file descriptor can be shifted around with <tt><a href="http://www.FreeBSD.org/cgi/man.cgi?query=dup&apropos=0&sektion=0&manpath=FreeBSD+4.3-RELEASE&format=html">dup(2)</a></tt>
when convenient. That is, the actual file descriptor on top of which a port is
constructed can be shifted around underneath the port by the scsh kernel when
necessary.  This is important, because when the user is setting up file
descriptors prior to a <tt><a href="http://www.FreeBSD.org/cgi/man.cgi?query=exec&apropos=0&sektion=0&manpath=FreeBSD+4.3-RELEASE&format=html">exec(2)</a></tt>, he may explicitly use a file descriptor
that has already been allocated to some port. In this case, the scsh kernel
just shifts the port's file descriptor to some new location with <tt>dup</tt>,
freeing up its old descriptor.  This prevents errors from happening in the
following scenario.  Suppose we have a file open on port <tt>f</tt>.  Now we want
to run a program that reads input on file 0, writes output to file 1, errors
to file 2, and logs execution information on file 3. We want to run this
program with input from <tt>f</tt>. 
So we write:
</p>
<blockquote><tt><br>
(run&nbsp;(/usr/shivers/bin/prog)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&gt;&nbsp;1&nbsp;output.txt)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&gt;&nbsp;2&nbsp;error.log)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&gt;&nbsp;3&nbsp;trace.log)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(=&nbsp;0&nbsp;,f))</tt></blockquote>
Now, suppose by ill chance that, unbeknownst to us, when the operating system
opened <tt>f</tt>'s file, it allocated descriptor 3 for it. If we blindly redirect
<tt>trace.log</tt> into file descriptor 3, we'll clobber <tt>f</tt>! However, the
port-shuffling machinery saves us: when the <tt>run</tt> form tries to dup
<tt>trace.log</tt>'s file descriptor to 3, <tt>dup</tt> will notice that file
descriptor 3 is already associated with an unrevealed port (<em>i.e.</em>, <tt>f</tt>). So,
it will first move <tt>f</tt> to some other file descriptor. This keeps <tt>f</tt>
alive and well so that it can subsequently be dup'd into descriptor 0 for
<tt>prog</tt>'s stdin.<p>
The port-shifting machinery makes the following guarantee: a port is only
moved when the underlying file descriptor is closed, either by a <tt><a href="http://www.FreeBSD.org/cgi/man.cgi?query=close&apropos=0&sektion=0&manpath=FreeBSD+4.3-RELEASE&format=html">close()</a></tt>
or a <tt><a href="http://www.FreeBSD.org/cgi/man.cgi?query=dup2&apropos=0&sektion=0&manpath=FreeBSD+4.3-RELEASE&format=html">dup2()</a></tt> operation. Otherwise a port/file-descriptor association is
stable.</p>
<p>
Under normal circumstances, all this machinery just works behind the scenes to
keep things straightened out. The only time the user has to think about it is
when he starts accessing file descriptors from ports, which he should almost
never have to do. If a user starts asking what file descriptors have been
allocated to what ports, he has to take responsibility for managing this
information.</p>
<p>
</p>
<a name="node_sec_3.2.5"></a>
<h3><a href="man-Z-H-1.html#node_toc_node_sec_3.2.5">3.2.5&nbsp;&nbsp;Port-mapping machinery</a></h3><p>The procedures provided in this section are almost never needed.
You may safely skim or completely skip this section on a first reading.</p>
<p>
Here are the routines for manipulating ports in scsh. The important
points to remember are:
</p>
<ul>
<li><p>A file port is associated with an open file, not a particular file
descriptor.
</p>
<li><p>The association between a file port and a particular file descriptor
is never changed <em>except</em> when the file descriptor is explicitly
closed. ``Closing'' includes being used as the target of a <tt>dup2</tt>, so
the set of procedures below that close their targets are
<tt>close</tt>, two-argument <tt>dup</tt>, and <tt>move-&gt;fdes</tt>.
If the target file descriptor of one of these routines has an
allocated port, the port will be shifted to another freshly-allocated
file descriptor, and marked as unrevealed, thus preserving the port
but freeing its old file descriptor.
</p>
</ul><p>
These rules are what is necessary to ``make things work out'' with no
surprises in the general case.</p>
<p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_114"></a></p>
<div align=left><tt>(fdes-&gt;inport <i>fd</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>port</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_116"></a><div align=left><tt>(fdes-&gt;outport <i>fd</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>port</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_118"></a><div align=left><tt>(port-&gt;fdes <i>port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>fixnum</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
These increment the port's revealed count.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_120"></a></p>
<div align=left><tt>(port-revealed <i>port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>integer</i> or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Return the port's revealed count if positive, otherwise <tt>#f</tt>.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_122"></a></p>
<div align=left><tt>(release-port-handle <i>port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Decrement the port's revealed count.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_124"></a></p>
<div align=left><tt>(call/fdes <i>fd/port consumer</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>value(s) of consumer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Calls <i>consumer</i> on a file descriptor; 
takes care of revealed bookkeeping.
If <i>fd/port</i> is a file descriptor, this is just 
<tt>(<i>consumer</i> <i>fd/port</i>)</tt>.
If <i>fd/port</i> is a port, 
calls <i>consumer</i> on its underlying file descriptor.
While <i>consumer</i> is running, the port's revealed count is incremented.<p>
When <tt>call/fdes</tt> is called with port argument, you are not allowed to
throw into <i>consumer</i> with a stored continuation, as that would violate
the revealed-count bookkeeping.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_126"></a></p>
<div align=left><tt>(move-&gt;fdes <i>fd/port target-fd</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>port or fdes</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Maps fd-->fd and port-->port.<p>
If <i>fd/port</i> is a file-descriptor not equal to <i>target-fd</i>, 
dup it to <i>target-fd</i> and close it. Returns <i>target-fd</i>. </p>
<p>
If <i>fd/port</i> is a port, it is shifted to <i>target-fd</i>, 
by duping its underlying file-descriptor if necessary. 
<i>Fd/port</i>'s original file descriptor is
closed (if it was different from <i>target-fd</i>). 
Returns the port. 
This operation resets <i>fd/port</i>'s revealed count to 1.</p>
<p>
In all cases when <i>fd/port</i> is actually shifted, if there is a port
already using <i>target-fd</i>, it is first relocated to some other file
descriptor.
</p>
</blockquote><p>
</p>
<a name="node_sec_3.2.6"></a>
<h3><a href="man-Z-H-1.html#node_toc_node_sec_3.2.6">3.2.6&nbsp;&nbsp;Unix I/O</a></h3><p></p>
<p></p>
<p></p>
<p><a name="node_idx_128"></a></p>
<div align=left><tt>(dup <i>fd/port [newfd]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>fd/port</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_130"></a><div align=left><tt>(dup-&gt;inport <i>fd/port [newfd]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>port</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_132"></a><div align=left><tt>(dup-&gt;outport <i>fd/port [newfd]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>port</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_134"></a><div align=left><tt>(dup-&gt;fdes <i>fd/port [newfd]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>fd</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
These procedures provide the functionality of C's <tt><a href="http://www.FreeBSD.org/cgi/man.cgi?query=dup&apropos=0&sektion=0&manpath=FreeBSD+4.3-RELEASE&format=html">dup()</a></tt> and <tt><a href="http://www.FreeBSD.org/cgi/man.cgi?query=dup2&apropos=0&sektion=0&manpath=FreeBSD+4.3-RELEASE&format=html">dup2()</a></tt>.
The different routines return different types of values:
<tt>dup-&gt;inport</tt>, <tt>dup-&gt;outport</tt>, and <tt>dup-&gt;fdes</tt> return
input ports, output ports, and integer file descriptors, respectively.
<tt>dup</tt>'s return value depends on on the type of 
<i>fd/port</i> -- it maps fd-->fd and port-->port.<p>
These procedures use the Unix <tt><a href="http://www.FreeBSD.org/cgi/man.cgi?query=dup&apropos=0&sektion=0&manpath=FreeBSD+4.3-RELEASE&format=html">dup()</a></tt> syscall to replicate
the file descriptor or file port <i>fd/port</i>.
If a <i>newfd</i> file descriptor is given, it is used as the target of
the dup operation, <em>i.e.</em>, the operation is a <tt><a href="http://www.FreeBSD.org/cgi/man.cgi?query=dup2&apropos=0&sektion=0&manpath=FreeBSD+4.3-RELEASE&format=html">dup2()</a></tt>.
In this case, procedures that return a port (such as <tt>dup-&gt;inport</tt>)
will return one with the revealed count set to one.
For example, <tt>(dup (current-input-port) 5)</tt> produces
a new port with underlying file descriptor 5, whose revealed count is 1.
If <i>newfd</i> is not specified, 
then the operating system chooses the file descriptor, 
and any returned port is marked as unrevealed.</p>
<p>
If the <i>newfd</i> target is given, 
and some port is already using that file descriptor,
the port is first quietly shifted (with another <tt>dup</tt>) 
to some other file descriptor (zeroing its revealed count).</p>
<p>
Since Scheme doesn't provide read/write ports, <tt>dup-&gt;inport</tt> and
<tt>dup-&gt;outport</tt> can be useful for getting an output version of an
input port, or <em>vice versa</em>.  For example, if <tt>p</tt> is an input
port open on a tty, and we would like to do output to that tty, we can
simply use <tt>(dup-&gt;outport p)</tt> to produce an equivalent output port
for the tty. Be sure to open the file with the <tt>open/read+write</tt>
flag for this.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_136"></a></p>
<div align=left><tt>(seek <i>fd/port offset [whence]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Reposition the I/O cursor for a file descriptor or port.
<i>whence</i> is one of {<tt>seek/set</tt>, <tt>seek/delta</tt>, <tt>seek/end</tt>},
and defaults to <tt>seek/set</tt>.
If <tt>seek/set</tt>, then <i>offset</i> is an absolute index into the file;
if <tt>seek/delta</tt>, then <i>offset</i> is a relative offset from the current
I/O cursor;
if <tt>seek/end</tt>, then <i>offset</i> is a relative offset from the end of file.
The <i>fd/port</i> argument may be a port or an integer file descriptor.
Not all such values are seekable;
this is dependent on the OS implementation.
The return value is the resulting position of the I/O cursor in the I/O stream.
<blockquote><i>Oops: </i> The current implementation doesn't handle <i>offset</i> arguments
that are not immediate integers (<em>i.e.</em>, representable in 30 bits).</blockquote>
<blockquote><i>Oops: </i> The current implementation doesn't handle buffered ports.</blockquote>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_138"></a></p>
<div align=left><tt>(tell <i>fd/port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Returns the position of the I/O cursor in the the I/O stream.
Not all file descriptors or ports support cursor-reporting; 
this is dependent on the OS implementation.
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_140"></a><div align=left><tt>(open-file <i>fname flags [perms]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>port</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
<i>Perms</i> defaults to <tt>#o666</tt>.
<i>Flags</i> is an integer bitmask, composed by or'ing together constants
listed in table&nbsp;<a href="#node_tbl_Temp_5">1</a> 
(page&nbsp;<a href="">4</a>).
You must use exactly one of the <tt>open/read</tt>, <tt>open/write</tt>, or
<tt>open/read+write</tt> flags.
The returned port is an input port if the <i>flags</i> permit it, 
otherwise an output port. R5RS/Scheme 48/scsh do not have input/output ports,
so it's one or the other. This should be fixed. (You can hack simultaneous
I/O on a file by opening it r/w, taking the result input port, 
and duping it to an output port with <tt>dup-&gt;outport</tt>.)
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_142"></a></p>
<div align=left><tt>(open-input-file <i>fname [flags]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>port</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_144"></a><div align=left><tt>(open-output-file <i>fname [flags perms]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>port</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>These are equivalent to <tt>open-file</tt>, after first setting the
read/write bits of the <i>flags</i> argument to <tt>open/read</tt> or
<tt>open/write</tt>, respectively.
<i>Flags</i> defaults to zero for <tt>open-input-file</tt>, 
and 
<blockquote><tt>(bitwise-ior open/create open/truncate)</tt></blockquote>for <tt>open-output-file</tt>.
These defaults make the procedures backwards-compatible with their
unary R5RS definitions.
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_146"></a><div align=left><tt>(open-fdes <i>fname flags [perms]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns a file descriptor.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_148"></a></p>
<div align=left><tt>(fdes-flags <i>fd/port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_150"></a><div align=left><tt>(set-fdes-flags <i>fd/port <i>integer</i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
These procedures allow reading and writing of an open file's flags.
The only such flag defined by P<small>O</small><small>S</small><small>I</small><small>X</small> is <tt>fdflags/close-on-exec</tt>;
your Unix implementation may provide others.<p>
These procedures should not be particularly useful to the programmer,
as the scsh runtime already provides automatic control of the close-on-exec
property.
Unrevealed ports always have their file descriptors marked
close-on-exec, as they can be closed when the scsh process execs a new program.
Whenever the user reveals or unreveals a port's file descriptor, 
the runtime automatically sets or clears the flag for the programmer.
Programmers that manipulate this flag should be aware of these extra, automatic
operations.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_152"></a></p>
<div align=left><tt>(fdes-status <i>fd/port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_154"></a><div align=left><tt>(set-fdes-status <i>fd/port <i>integer</i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
These procedures allow reading and writing of an open file's status flags
(table&nbsp;<a href="#node_tbl_Temp_5">1</a>).
<p></p>
<hr>
<p></p>
<a name="node_tbl_Temp_5"></a>
<div class=table align=center><table width=100%><tr><td align=center><div align=center><table><tr><td>

<table border=0><tr><td valign=top ></td><td valign=top >Allowed operations </td><td valign=top >Status flag </td></tr>
<tr><td valign=top >
<b>Open+Get+Set</b> </td><td valign=top >These flags can be used in <tt>open-file</tt>, <tt>fdes-status</tt>,
and <tt>set-fdes-status</tt> calls. </td><td valign=top ><table border=0><tr><td valign=top >open/append         </td></tr>
<tr><td valign=top >open/non-blocking   </td></tr>
<tr><td valign=top >open/async (Non-P<small>O</small><small>S</small><small>I</small><small>X</small>) </td></tr>
<tr><td valign=top >open/fsync (Non-P<small>O</small><small>S</small><small>I</small><small>X</small>)
</td></tr></table>
</td></tr>
<tr><td valign=top >
<b>Open+Get</b> </td><td valign=top >These flags can be used in <tt>open-file</tt> and <tt>fdes-status</tt> calls,
but are ignored by <tt>set-fdes-status</tt>. </td><td valign=top ><table border=0><tr><td valign=top >open/read           </td></tr>
<tr><td valign=top >open/write          </td></tr>
<tr><td valign=top >open/read+write     </td></tr>
<tr><td valign=top >open/access-mask
</td></tr></table>
</td></tr>
<tr><td valign=top >
<b>Open</b> </td><td valign=top >These flags are only relevant in 
<tt>open-file</tt> calls; 
they are ignored by <tt>fdes-status</tt> and <tt>set-fdes-status</tt> calls. </td><td valign=top ><table border=0><tr><td valign=top >open/create         </td></tr>
<tr><td valign=top >open/exclusive              </td></tr>
<tr><td valign=top >open/no-control-tty </td></tr>
<tr><td valign=top >open/truncate               
</td></tr></table>
</td></tr></table>
</td></tr></table></div>

</td></tr>
<tr><td align=center><b>Table 1:</b>&nbsp;&nbsp;Status flags for <tt>open-file</tt>,
<tt>fdes-status</tt> and <tt>set-fdes-status</tt>.
Only P<small>O</small><small>S</small><small>I</small><small>X</small> flags are guaranteed to be present;
your operating system may define others.
The <tt>open/access-mask</tt> value is not an actual flag,
but a bit mask used to select the field for the <tt>open/read</tt>,
<tt>open/write</tt> and <tt>open/read+write</tt> bits.
</td></tr>
<tr><td>

</td></tr></table></div><p></p>
<hr>
<p></p>
<p></p>
<p>
Note that this file-descriptor state is shared between file descriptors
created by <tt>dup</tt> -- if you create port <i>b</i> by applying <tt>dup</tt>
to port <i>a</i>, and change <i>b</i>'s status flags, you will also have
changed <i>a</i>'s status flags.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_156"></a><div align=left><tt>(pipe<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>[<i>rport</i> <i>wport</i>]</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Returns two ports, the read and write end-points of a Unix pipe.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_158"></a></p>
<div align=left><tt>(read-string <i>nbytes [fd/port]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i> or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_160"></a><div align=left><tt>(read-string! <i>str [fd/port start end]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>nread or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
These calls read exactly as much data as you requested, unless
there is not enough data (eof). 
<tt>read-string!</tt> reads the data into string <i>str</i>
at the indices in the half-open interval [<i>start</i>,<i>end</i>);
the default interval is the whole string: <i>start</i> = 0 and
<i>end</i> = <tt>(string-length <i>string</i>)</tt>.
They will persistently retry on partial reads and when interrupted
until (1) error, (2) eof, or (3) the input request is completely
satisfied.
Partial reads can occur when reading from an intermittent source,
such as a pipe or tty.<p>
<tt>read-string</tt> returns the string read; <tt>read-string!</tt> returns
the number of characters read. They both return false at eof.
A request to read zero bytes returns immediately, with no eof check.</p>
<p>
The values of <i>start</i> and <i>end</i> must specify a well-defined
interval in <i>str</i>, 
<em>i.e.</em>, 0 <u>&lt;</u> <i>start</i> <u>&lt;</u> <i>end</i> <u>&lt;</u> <tt>(string-length <i>str</i>)</tt>.</p>
<p>
Any partially-read data is included in the error exception packet.
Error returns on non-blocking input are considered an error.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_162"></a></p>
<div align=left><tt>(read-string/partial <i>nbytes [fd/port]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i> or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_164"></a><div align=left><tt>(read-string!/partial <i>str [fd/port start end]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>nread or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
These are atomic best-effort/forward-progress calls. 
Best effort: they may read less than you request if there is a
lesser amount of data immediately available (<em>e.g.</em>, because you
are reading from a pipe or a tty).
Forward progress: if no data is immediately available 
(<em>e.g.</em>, empty pipe), they will block.
Therefore, if you request an <em>n</em>&gt;0 byte read, 
while you may not get everything you asked for, you will always get something
(barring eof).<p>
There is one case in which the forward-progress guarantee is cancelled:
when the programmer explicitly sets the port to non-blocking I/O.
In this case, if no data is immediately available, 
the procedure will not block, but will immediately return a zero-byte read.</p>
<p>
<tt>read-string/partial</tt> reads the data into a freshly allocated string,
which it returns as its value.
<tt>read-string!/partial</tt> reads the data into string <i>str</i>
at the indices in the half-open interval [<i>start</i>,<i>end</i>);
the default interval is the whole string: <i>start</i> = 0 and
<i>end</i> = <tt>(string-length <i>string</i>)</tt>.
The values of <i>start</i> and <i>end</i> must specify a well-defined
interval in <i>str</i>, 
<em>i.e.</em>, 0 <u>&lt;</u> <i>start</i> <u>&lt;</u> <i>end</i> <u>&lt;</u> <tt>(string-length <i>str</i>)</tt>.
It returns the number of bytes read.</p>
<p>
A request to read zero bytes returns immediatedly, with no eof check.</p>
<p>
In sum, there are only three ways you can get a zero-byte read:
(1) you request one, (2) you turn on non-blocking I/O, or (3) you
try to read at eof.</p>
<p>
These are the routines to use for non-blocking input.
They are also useful when you wish to efficiently process data
in large blocks, and your algorithm is insensitive to the block size
of any particular read operation.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_166"></a></p>
<div align=left><tt>(select  <i>rvec wvec evec [timeout]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>[rvec' wvec' evec']</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_168"></a><div align=left><tt>(select! <i>rvec wvec evec [timeout]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>[nr nw ne]</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
The <tt>select</tt> procedure allows a process to block and wait for
events on multiple I/O channels.  The <i>rvec</i> and <i>evec</i>
arguments are vectors of input ports and integer file descriptors;
<i>wvec</i> is a vector of output ports and integer file
descriptors.  The procedure returns three vectors whose elements
are subsets of the corresponding arguments.  Every element of
<i>rvec'</i> is ready for input; every element of <i>wvec'</i> is
ready for output; every element of <i>evec'</i> has an exceptional
condition pending.<p>
The <tt>select</tt> call will block until at least one of the I/O
channels passed to it is ready for operation.  For an input port
this means that it either has data sitting its buffer or that the
underlying file descriptor has data waiting.  For an output port
this means that it either has space available in the associated
buffer or that the underlying file descriptor can accept output.
For file descriptors, no buffers are checked, even if they have
associated ports.</p>
<p>
The <i>timeout</i> value can be used to force the call to time-out
after a given number of seconds. It defaults to the special value
<tt>#f</tt>, meaning wait indefinitely. A zero value can be used to
poll the I/O channels.</p>
<p>
If an I/O channel appears more than once in a given
vector -- perhaps occuring once as a Scheme port, and once as the
port's underlying integer file descriptor -- only one of these two
references may appear in the returned vector.  Buffered I/O ports
are handled specially -- if an input port's buffer is not empty, or
an output port's buffer is not yet full, then these ports are
immediately considered eligible for I/O without using the actual,
primitive <tt>select</tt> system call to check the underlying file
descriptor.  This works pretty well for buffered input ports, but
is a little problematic for buffered output ports.</p>
<p>
The <tt>select!</tt> procedure is similar, but indicates the subset of
active I/O channels by side-effecting the argument vectors.
Non-active I/O channels in the argument vectors are overwritten
with <tt>#f</tt> values.  The call returns the number of active
elements remaining in each vector.  As a convenience, the vectors
passed in to <tt>select!</tt> are allowed to contain <tt>#f</tt> values
as well as integers and ports.</p>
<p>
</p>
<blockquote><i>Remark: </i> <tt>Select</tt> and <tt>select!</tt> do not
call their POSIX counterparts directly -- there is a POSIX
<tt>select</tt> sitting at the very heart of the Scheme 48/scsh
I/O system, so <em>all</em> multiplexed I/O is really
<tt>select</tt>-based.  Therefore, you cannot expect a
performance increase from writing a single-threaded program
using <tt>select</tt> and <tt>select!</tt> instead of writing a
multi-threaded program where each thread handles one I/O
connection.<p>
The moral of this story is that <tt>select</tt> and
<tt>select!</tt> make sense in only two situations: legacy code
written for an older version of scsh, and programs which make
inherent use of <tt>select</tt>/<tt>select!</tt> which do not
benefit from multiple threads.  Examples are network clients
that send requests to multiple alternate servers and discard all
but one of them.</p>
<p>
In any case, the <tt>select-ports</tt> and
<tt>select-port-channels</tt> procedures described below
are usually a preferable alternative to
<tt>select</tt>/<tt>select!</tt>: they are much simpler to use, and
also have a slightly more efficient implementation.</p>
</blockquote>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_170"></a></p>
<div align=left><tt>(select-ports <i>timeout port <tt>...</tt></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>ready-ports</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
The <tt>select-ports</tt> call will block until at least one of the
ports passed to it is ready for operation or until the timeout has
expired.  For an input port this means that it either has data
sitting its buffer or that the underlying file descriptor has data
waiting.  For an output port this means that it either has space
available in the associated buffer or that the underlying file
descriptor can accept output.<p>
The <i>timeout</i> value can be used to force the call to time out
after a given number of seconds.  A value of <tt>#f</tt> means to wait
indefinitely.  A zero value can be used to poll the ports.</p>
<p>
<tt>Select-ports</tt> returns a list of the ports ready for
operation.  Note that this list may be empty if the timeout expired
before any ports became ready.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_172"></a></p>
<div align=left><tt>(select-port-channels <i>timeout port <tt>...</tt></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>ready-ports</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
<tt>Select-port-channels</tt> is like <tt>select-ports</tt>, except
that it only looks at the operating system objects the ports refer
to, ignoring any buffering performed by the ports.<p>
</p>
<blockquote><i>Remark: </i> <tt>Select-port-channels</tt> should be used with care: for
example, if an input port has data in the buffer but no data
available on the underlying file descriptor,
<tt>select-port-channels</tt> will block, even though a read
operation on the port would be able to complete without blocking.<p>
<tt>Select-port-channels</tt> is intended for situations where the
program is not checking for available data, but rather for waiting
until a port has established a connection -- for example, to a
network port.</p>
</blockquote>
</blockquote><p>
</p>
<a name="node_idx_174"></a><div align=left><tt>(write-string <i>string [fd/port start end]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>This procedure writes all the data requested. 
If the procedure cannot perform the write with a single kernel call
(due to interrupts or partial writes),
it will perform multiple write operations until all the data is written
or an error has occurred.
A non-blocking I/O error is considered an error.
(Error exception packets for this syscall include the amount of
data partially transferred before the error occurred.)<p>
The data written are the characters of <i>string</i> in the half-open
interval [<i>start</i>,<i>end</i>).
The default interval is the whole string: <i>start</i> = 0 and
<i>end</i> = <tt>(string-length <i>string</i>)</tt>.
The values of <i>start</i> and <i>end</i> must specify a well-defined
interval in <i>str</i>, 
<em>i.e.</em>, 0 <u>&lt;</u> <i>start</i> <u>&lt;</u> <i>end</i> <u>&lt;</u> <tt>(string-length <i>str</i>)</tt>.
A zero-byte write returns immediately, with no error.</p>
<p>
Output to buffered ports: <tt>write-string</tt>'s efforts end as soon
as all the data has been placed in the output buffer.
Errors and true output may not happen until a later time, of course.
</p>
</blockquote><p>
</p>
<a name="node_idx_176"></a><div align=left><tt>(write-string/partial <i>string [fd/port start end]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>nwritten</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
This routine is the atomic best-effort/forward-progress analog
to <tt>write-string</tt>.
It returns the number of bytes written, which may be less than you
asked for.
Partial writes can occur when (1) we write off the physical end of
the media, (2) the write is interrrupted, or (3) the file descriptor
is set for non-blocking I/O.<p>
If the file descriptor is not set up for non-blocking I/O, then
a successful return from these procedures makes a forward progress
guarantee -- that is, a partial write took place of at least one byte:
</p>
<ul>
<li><p>If we are at the end of physical media, and no write takes place,
an error exception is raised.
So a return implies we wrote <em>something</em>.
</p>
<li><p>If the call is interrupted after a partial transfer, it returns
immediately. But if the call is interrupted before any data transfer,
then the write is retried.
</p>
</ul><p></p>
<p>
If we request a zero-byte write, then the call immediately returns 0.
If the file descriptor is set for non-blocking I/O, then the call
may return 0 if it was unable to immediately write anything
(<em>e.g.</em>, full pipe).
Barring these two cases, a write either returns <i>nwritten</i> &gt; 0, 
or raises an error exception.</p>
<p>
Non-blocking I/O is only available on file descriptors and unbuffered
ports. Doing non-blocking I/O to a buffered port is not well-defined,
and is an error (the problem is the subsequent flush operation).</p>
<p>
</p>
<blockquote><i>Oops: </i> <tt>write-string/partial</tt> is currently not implemented.
Consider using threads to achive the same functionality.</blockquote>
</blockquote><p>
</p>
<a name="node_sec_3.2.7"></a>
<h3><a href="man-Z-H-1.html#node_toc_node_sec_3.2.7">3.2.7&nbsp;&nbsp;Buffered I/O</a></h3><p>Scheme 48 ports use buffered I/O -- data is transferred to or from the
OS in blocks. Scsh provides control of this mechanism: the programmer
may force saved-up output data to be transferred to the OS when
he chooses, 
and may also choose which I/O buffering policy to employ for a given
port (or turn buffering off completely). </p>
<p>
It can be useful to turn I/O buffering off in some cases, for example
when an I/O stream is to be shared by multiple subprocesses.
For this reason, scsh allocates an unbuffered port for file descriptor 0
at start-up time.
Because shells frequently share stdin with subprocesses, if the shell
does buffered reads, it might ``steal'' input intended for a subprocess.  For
this reason, all shells, including sh, csh, and scsh, read stdin unbuffered.
Applications that can tolerate buffered input on stdin can reset
<tt>(current-input-port)</tt> to block buffering for higher performance.</p>
<p>
{Note So support <tt>peek-char</tt> a Scheme implementation has to
maintain a buffer for all input ports. In scsh, for ``unbuffered''
input ports the buffer size is one. As you cannot request less then
one character there is no unrequested reading so this can still be
called ``unbuffered input''.}</p>
<p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_178"></a><div align=left><tt>(set-port-buffering <i>port policy [size]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>This procedure allows the programmer to assign a particular I/O buffering
policy to a port, and to choose the size of the associated buffer.
It may only be used on new ports, <em>i.e.</em>, before I/O is performed on the port.
There are three buffering policies that may be chosen:
<blockquote>
<table border=0><tr><td valign=top ><a name="node_idx_180"></a><tt>bufpol/block</tt> </td><td valign=top >General block buffering (general default) </td></tr>
<tr><td valign=top ><a name="node_idx_182"></a><tt>bufpol/line</tt>  </td><td valign=top >Line buffering (tty default) </td></tr>
<tr><td valign=top ><a name="node_idx_184"></a><tt>bufpol/none</tt>  </td><td valign=top >Direct I/O -- no buffering<a name="call_footnote_Temp_6"></a><a href="#footnote_Temp_6"><sup><small>4</small></sup></a>
</td></tr></table>
</blockquote>
The line buffering policy flushes output whenever a newline is output;
whenever the buffer is full; or whenever an input is read from stdin.
Line buffering is the default for ports open on terminal devices.
<blockquote><i>Oops: </i> The current implementation doesn't support <tt>bufpol/line</tt>.</blockquote><p>
The <i>size</i> argument requests an I/O buffer of <i>size</i> bytes.
For output ports, <i>size</i> must be non-negative, for input ports
<i>size</i> must be positve. If not given, a reasonable default is
used. For output ports, if given and zero, buffering is turned off
(<em>i.e.</em>, <i>size</i>  =  0 for any policy is equivalent to <i>policy</i>  = 
<tt>bufpol/none</tt>). For input ports, setting the size to one
corresponds to unbuffered input as defined above. If given, <i>size</i>
must be zero respectively one for <tt>bufpol/none</tt>.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_186"></a><div align=left><tt>(force-output <i>[fd/port]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
This procedure does nothing when applied to an integer file descriptor 
or unbuffered port.
It flushes buffered output when applied to a buffered port,
and raises a write-error exception on error. Returns no value.
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_188"></a><div align=left><tt>(flush-all-ports<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
This procedure flushes all open output ports with buffered data.
</blockquote><p>
</p>
<a name="node_sec_3.2.8"></a>
<h3><a href="man-Z-H-1.html#node_toc_node_sec_3.2.8">3.2.8&nbsp;&nbsp;File locking</a></h3><p>
Scsh provides P<small>O</small><small>S</small><small>I</small><small>X</small> advisory file locking.
<em>Advisory</em> locks are locks that can be checked by user code, 
but do not affect other I/O operations.
For example, if a process has an exclusive lock on a region of a file,
other processes will not be able to obtain locks on that region of the file,
but they will still be able to read and write the file with no hindrance.
Using advisory locks requires cooperation amongst the agents accessing
the shared resource.</p>
<p>
</p>
<blockquote><i>Remark: </i> 
Unfortunately, P<small>O</small><small>S</small><small>I</small><small>X</small> file locks are associated with actual files,
not with associated open file descriptors.
Once a process locks a file, using some file descriptor <i>fd</i>,
the next time <em>any</em> file descriptor referencing that file is closed, 
all associated locks are released.
This severely limits the utility of P<small>O</small><small>S</small><small>I</small><small>X</small> advisory file locks,
and we'd recommend caution when using them.
It is not without reason that the FreeBSD man pages refer to P<small>O</small><small>S</small><small>I</small><small>X</small>
file locking as ``completely stupid.''<p>
Scsh moves Scheme ports from file descriptor to file descriptor with 
<tt><a href="http://www.FreeBSD.org/cgi/man.cgi?query=dup&apropos=0&sektion=0&manpath=FreeBSD+4.3-RELEASE&format=html">dup()</a></tt> and <tt><a href="http://www.FreeBSD.org/cgi/man.cgi?query=close&apropos=0&sektion=0&manpath=FreeBSD+4.3-RELEASE&format=html">close()</a></tt> as required by the runtime, 
so it is impossible to keep file locks open across one of these shifts.
Hence we can only offer P<small>O</small><small>S</small><small>I</small><small>X</small> advisory file locking directly on raw
integer file descriptors; 
regrettably, there are no facilities for locking Scheme ports.</p>
<p>
Note that once a Scheme port is revealed in scsh, the runtime will not
shift the port around with <tt><a href="http://www.FreeBSD.org/cgi/man.cgi?query=dup&apropos=0&sektion=0&manpath=FreeBSD+4.3-RELEASE&format=html">dup()</a></tt> and <tt><a href="http://www.FreeBSD.org/cgi/man.cgi?query=close&apropos=0&sektion=0&manpath=FreeBSD+4.3-RELEASE&format=html">close()</a></tt>.
This means the file-locking procedures can then be applied to the port's
associated file descriptor.
</p>
</blockquote><p>
P<small>O</small><small>S</small><small>I</small><small>X</small> allows the user to lock a region of a file with either 
an exclusive or shared lock.
Locked regions are described by the <em>lock-region</em> record:
</p>
<blockquote><tt><br>
(define-record&nbsp;lock-region<br>
&nbsp;&nbsp;exclusive?<br>
&nbsp;&nbsp;start<br>
&nbsp;&nbsp;len<br>
&nbsp;&nbsp;whence<br>
&nbsp;&nbsp;proc)</tt></blockquote><a name="node_idx_190"></a><a name="node_idx_192"></a> <a name="node_idx_194"></a><a name="node_idx_196"></a> <a name="node_idx_198"></a><a name="node_idx_200"></a> <a name="node_idx_202"></a><ul>
<li><p>The <tt>exclusive?</tt> field is true if the lock is exclusive; 
false if it is shared.</p>
<p>
</p>
<li><p>The <tt>whence</tt> field is one of the values from the <tt>seek</tt> call:
<tt>seek/set</tt>, <tt>seek/delta</tt>, or <tt>seek/end</tt>, 
and determines the interpretation of the <tt>start</tt> field:
</p>
<ul>
<li><p>If <tt>seek/set</tt>, the <tt>start</tt> value is simply an absolute index
into the file.
</p>
<li><p>If <tt>seek/delta</tt>, the <tt>start</tt> value is an offset from the 
file descriptor's current position in the file.
</p>
<li><p>If <tt>seek/end</tt>, the <tt>start</tt> value is an offset from the 
end of the file.
</p>
</ul><p>
The region of the file being locked is given by the <tt>start</tt> and <tt>len</tt>
fields;
if <tt>len</tt> is zero, it means ``infinity,'' that is, the region extends
from the starting point through the end of the file, even as the file is
extended by subsequent write operations.</p>
<p>
</p>
<li><p>The <tt>proc</tt> field gives the process object for the process holding the region
lock, when relevant (see <tt>get-lock-region</tt> below).
</p>
</ul><p></p>
<p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_204"></a><div align=left><tt>(make-lock-region <i>exclusive? start len [whence]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>lock-region</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
This procedure makes a lock-region record. 
The <tt>whence</tt> field defaults to <tt>seek/set</tt>.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_206"></a></p>
<div align=left><tt>(lock-region <i>fdes lock</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_208"></a><div align=left><tt>(lock-region/no-block <i>fdes lock</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
These procedures lock a region of the file referenced by file descriptor
<i>fdes</i>.
The <tt>lock-region</tt> procedure blocks until the lock is granted;
the non-blocking variant returns a boolean indicating whether or not
the lock was granted.
To take an exclusive (write) lock, you must have the file descriptor
open with write access;
to take a shared (read) lock, you must have the file descriptor
open with read access.
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_210"></a><div align=left><tt>(get-lock-region <i>fdes lock</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>lock-region or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Return the first lock region on <i>fdes</i> that would conflict with 
lock region <i>lock</i>.
If there is no such lock region, return false.
This procedure fills out the <tt>proc</tt> field of the returned lock region,
and is the only procedure that has anything to do with this field.
(See section&nbsp;<a href="#node_sec_3.4.1">3.4.1</a> for a description of process objects.)
Note that if you apply this procedure to a file system that is shared
across multiple operating systems (<em>i.e.</em>, an NFS file system), the <tt>proc</tt>
field may be ambiguous.
We note, again, that P<small>O</small><small>S</small><small>I</small><small>X</small> advisory file locking is not a terribly useful
or well-designed facility.
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_212"></a><div align=left><tt>(unlock-region <i>fdes lock</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Release a lock from a file.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_214"></a></p>
<div align=left><tt>(with-region-lock* <i>fdes lock thunk</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>value(s) of thunk</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_216"></a><div align=left><tt>(with-region-lock <i>fdes lock body <tt>...</tt></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>value(s) of body</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax)&nbsp;</div>

<blockquote>
This procedure obtains the requested lock, and then calls 
<tt>(<i>thunk</i>)</tt>. When <i>thunk</i> returns, the lock is released.
A non-local exit (<em>e.g.</em>, throwing to a saved continuation or raising
an exception) also causes the lock to be released.<p>
After a normal return from <i>thunk</i>, its return values are returned
by <tt>with-region-lock*</tt>.
The <tt>with-region-lock</tt> special form is equivalent syntactic sugar.
</p>
</blockquote><p>
</p>
<p>
</p>
<a name="node_sec_3.3"></a>
<h2><a href="man-Z-H-1.html#node_toc_node_sec_3.3">3.3&nbsp;&nbsp;File system</a></h2><p>Besides the following procedures, which allow access to the
computer's file system, scsh also provides a set of procedures
which manipulate file <em>names</em>. These string-processing
procedures are documented in section <a href="man-Z-H-6.html#node_sec_5.1">5.1</a>.</p>
<p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_218"></a></p>
<div align=left><tt>(create-directory <i>fname [perms override?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_220"></a><div align=left><tt>(create-fifo <i>fname [perms override?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_222"></a><div align=left><tt>(create-hard-link <i>oldname newname [override?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_224"></a><div align=left><tt>(create-symlink <i>old-name new-name [override?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote><p>
These procedures create objects of various kinds in the file system.</p>
<p>
The <i>override?</i> argument controls the action if there is already an
object in the file system with the new name:
</p>
<blockquote><table border=0><tr><td valign=top ><tt>#f</tt></td><td valign=top >signal an error (default) </td></tr>
<tr><td valign=top >'query      </td><td valign=top >prompt the user </td></tr>
<tr><td valign=top ><em>other</em></td><td valign=top >
delete the old object (with <tt>delete-file</tt>
or <tt>delete-directory,</tt> as appropriate) before
creating the new object.<p>
</p>
</td></tr></table></blockquote><p>
<i>Perms</i> defaults to <tt>#o777</tt> (but is masked by the current umask).</p>
<p>
</p>
<blockquote><i>Remark: </i> Currently, if you try to create a hard or symbolic link from a
file to itself, you will error out with <i>override?</i> false, and simply
delete your file with <i>override?</i> true. Catching this will require
some sort of true-name procedure, which I currently do not have.</blockquote>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_226"></a></p>
<div align=left><tt>(delete-directory <i>fname</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_228"></a><div align=left><tt>(delete-file <i>fname</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_230"></a><div align=left><tt>(delete-filesys-object <i>fname</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>These procedures delete objects from the file system.
The <tt>delete-filesys-object</tt> procedure will delete an object
of any type from the file system: files, (empty) directories, symlinks, fifos,
<em>etc.</em>.<p>
If the object being deleted doesn't exist, <tt>delete-directory</tt> and
<tt>delete-file</tt> raise an error, 
while <tt>delete-filesys-object</tt> simply returns.
</p>
</blockquote><p>
</p>
<a name="node_idx_232"></a><div align=left><tt>(read-symlink <i>fname</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Return the filename referenced by symbolic link <tt>fname</tt>.
</blockquote><p>
</p>
<a name="node_idx_234"></a><div align=left><tt>(rename-file <i>old-fname new-fname [override?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>If you override an existing object, then <i>old-fname</i> 
and <i>new-fname</i> must type-match -- either both directories, 
or both non-directories. 
This is required by the semantics of Unix <tt><a href="http://www.FreeBSD.org/cgi/man.cgi?query=rename&apropos=0&sektion=0&manpath=FreeBSD+4.3-RELEASE&format=html">rename()</a></tt>.<p>
</p>
<blockquote><i>Remark: </i> 
There is an unfortunate atomicity problem with the <tt>rename-file</tt> 
procedure: if you
specify no-override, but create file <tt>new-fname</tt> sometime between
<tt>rename-file</tt>'s existence check and the actual rename operation,
your file will be clobbered with <tt>old-fname</tt>. There is no way to fix
this problem, given the semantics of Unix <tt><a href="http://www.FreeBSD.org/cgi/man.cgi?query=rename&apropos=0&sektion=0&manpath=FreeBSD+4.3-RELEASE&format=html">rename()</a></tt>; 
at least it is highly unlikely to occur in practice.
</blockquote>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_236"></a></p>
<div align=left><tt>(set-file-mode <i>fname/fd/port mode</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_238"></a><div align=left><tt>(set-file-owner <i>fname/fd/port uid</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_240"></a><div align=left><tt>(set-file-group <i>fname/fd/port gid</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>    
These procedures set the permission bits, owner id, and group id of a
file, respectively.
The file can be specified by giving the file name, or either an
integer file descriptor or a port open on the file.
Setting file user ownership usually requires root privileges.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_242"></a></p>
<div align=left><tt>(set-file-times <i>fname [access-time mod-time]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
This procedure sets the access and modified times for the file
<i>fname</i> to the supplied values (see section&nbsp;<a href="#node_sec_3.10">3.10</a>
for the scsh representation of time).
If neither time argument is supplied, they are both taken to be
the current time. You must provide both times or neither.
If the procedure completes successfully, the file's time of last
status-change (<tt>ctime</tt>) is set to the current time.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_244"></a></p>
<div align=left><tt>(sync-file <i>fd/port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_246"></a><div align=left><tt>(sync-file-system<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Calling <tt>sync-file</tt>
causes Unix to update the disk data structures for a given file.
If <i>fd/port</i> is a port, any buffered data it may have is first
flushed. 
Calling <tt>sync-file-system</tt> synchronises the kernel's entire file
system with the disk.<p>
These procedures are not P<small>O</small><small>S</small><small>I</small><small>X</small>.
Interestingly enough, <tt>sync-file-system</tt> doesn't actually
do what it is claimed to do. We just threw it in for humor value.
See the <tt><a href="http://www.FreeBSD.org/cgi/man.cgi?query=sync&apropos=0&sektion=0&manpath=FreeBSD+4.3-RELEASE&format=html">sync(2)</a></tt> man page for Unix enlightenment.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_248"></a><div align=left><tt>(truncate-file <i>fname/fd/port len</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>The specified file is truncated to <i>len</i> bytes in length.
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_250"></a><div align=left><tt>(file-info <i>fname/fd/port [chase?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>file-info-record</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
The <tt>file-info</tt> procedure
returns a record structure containing everything
there is to know about a file. If the <i>chase?</i> flag is true
(the default), then the procedure chases symlinks and reports on
the files to which they refer. If <i>chase?</i> is false, then 
the procedure checks the actual file itself, even if it's a symlink.
The <i>chase?</i> flag is ignored if the file argument is a file descriptor
or port.<p>
The value returned is a <em>file-info record</em>, defined to have the
following structure:
</p>
<blockquote><tt><br>
(define-record&nbsp;file-info<br>
&nbsp;&nbsp;type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;{block-special,&nbsp;char-special,&nbsp;directory,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fifo,&nbsp;regular,&nbsp;socket,&nbsp;symlink}<br>
&nbsp;&nbsp;device&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;Device&nbsp;file&nbsp;resides&nbsp;on.<br>
&nbsp;&nbsp;inode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;File's&nbsp;inode.<br>
&nbsp;&nbsp;mode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;File's&nbsp;mode&nbsp;bits:&nbsp;permissions,&nbsp;setuid,&nbsp;setgid<br>
&nbsp;&nbsp;nlinks&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;Number&nbsp;of&nbsp;hard&nbsp;links&nbsp;to&nbsp;this&nbsp;file.<br>
&nbsp;&nbsp;uid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;Owner&nbsp;of&nbsp;file.<br>
&nbsp;&nbsp;gid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;File's&nbsp;group&nbsp;id.<br>
&nbsp;&nbsp;size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;Size&nbsp;of&nbsp;file,&nbsp;in&nbsp;bytes.<br>
&nbsp;&nbsp;atime&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;Time&nbsp;of&nbsp;last&nbsp;access.<br>
&nbsp;&nbsp;mtime&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;Time&nbsp;of&nbsp;last&nbsp;mod.<br>
&nbsp;&nbsp;ctime)&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;Time&nbsp;of&nbsp;last&nbsp;status&nbsp;change.</tt></blockquote>
<a name="node_idx_252"></a><a name="node_idx_254"></a><a name="node_idx_256"></a><a name="node_idx_258"></a><a name="node_idx_260"></a><a name="node_idx_262"></a><a name="node_idx_264"></a><a name="node_idx_266"></a><a name="node_idx_268"></a><a name="node_idx_270"></a><a name="node_idx_272"></a>The uid field of a file-info record is accessed with the procedure
<blockquote><tt>(file-info:uid x)</tt></blockquote>and similarly for the other fields. 
The <tt>type</tt> field is a symbol; all other fields are integers.
A file-info record is discriminated with the <tt>file-info?</tt> predicate.<p>
The following procedures all return selected information about
a file; they are built on top of <tt>file-info</tt>, and are
called with the same arguments that are passed to it.
</p>
<blockquote>
<table border=0><tr><td valign=top >Procedure </td><td valign=top >returns </td></tr>
<tr><td valign=top ><a name="node_idx_274"></a><tt>file-type</tt>          </td><td valign=top >type </td></tr>
<tr><td valign=top ><a name="node_idx_276"></a><tt>file-inode</tt>         </td><td valign=top >inode </td></tr>
<tr><td valign=top ><a name="node_idx_278"></a><tt>file-mode</tt>          </td><td valign=top >mode </td></tr>
<tr><td valign=top ><a name="node_idx_280"></a><tt>file-nlinks</tt>        </td><td valign=top >nlinks </td></tr>
<tr><td valign=top ><a name="node_idx_282"></a><tt>file-owner</tt>         </td><td valign=top >uid </td></tr>
<tr><td valign=top ><a name="node_idx_284"></a><tt>file-group</tt>         </td><td valign=top >gid </td></tr>
<tr><td valign=top ><a name="node_idx_286"></a><tt>file-size</tt>          </td><td valign=top >size </td></tr>
<tr><td valign=top ><a name="node_idx_288"></a><tt>file-last-access</tt>   </td><td valign=top >atime </td></tr>
<tr><td valign=top ><a name="node_idx_290"></a><tt>file-last-mod</tt>      </td><td valign=top >mtime </td></tr>
<tr><td valign=top ><a name="node_idx_292"></a><tt>file-last-status-change</tt> </td><td valign=top >ctime
</td></tr></table>
</blockquote>
Example:
<blockquote><tt>&nbsp;&nbsp;&nbsp;<br>
;;&nbsp;All&nbsp;my&nbsp;files&nbsp;in&nbsp;/usr/tmp:<br>
(filter&nbsp;(lambda&nbsp;(f)&nbsp;(=&nbsp;(file-owner&nbsp;f)&nbsp;(user-uid)))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(directory-files&nbsp;&quot;/usr/tmp&quot;)))</tt></blockquote><p>
</p>
<blockquote><i>Remark: </i> <tt>file-info</tt> was named <tt>file-attributes</tt> in releases of scsh
prior to release 0.4. We changed the name to <tt>file-info</tt> for
consistency with the other information-retrieval procedures in
scsh: <tt>user-info</tt>, <tt>group-info</tt>, <tt>host-info</tt>, 
<tt>network-info </tt>, <tt>service-info</tt>, and <tt>protocol-info</tt>.<p>
The <tt>file-attributes</tt> binding is still supported in the current
release of scsh, but is deprecated, and may go away in a future
release.</p>
</blockquote>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_294"></a></p>
<div align=left><tt>(file-directory? <i>fname/fd/port [chase?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_296"></a><div align=left><tt>(file-fifo? <i>fname/fd/port [chase?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_298"></a><div align=left><tt>(file-regular? <i>fname/fd/port [chase?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_300"></a><div align=left><tt>(file-socket? <i>fname/fd/port [chase?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_302"></a><div align=left><tt>(file-special? <i>fname/fd/port [chase?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_304"></a><div align=left><tt>(file-symlink? <i>fname/fd/port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
These procedures are file-type predicates that test the
type of a given file.
They are applied to the same arguments to which <tt>file-info</tt> is applied;
the sole exception is <tt>file-symlink?</tt>, which does not take
the optional <i>chase?</i> second argument.
<blockquote>
<table border=0><tr><td valign=top ></td></tr></table>
</blockquote>
For example,
<blockquote><tt>(file-directory? &quot;/usr/dalbertz&quot;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;===&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>#t</tt></tt></blockquote></blockquote><p>
There are variants of these procedures which work directly on
<tt>file-info</tt> records:
</p>
<p></p>
<p></p>
<p><a name="node_idx_306"></a></p>
<div align=left><tt>(file-info-directory? <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_308"></a><div align=left><tt>(file-info-fifo? <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_310"></a><div align=left><tt>(file-info-regular? <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_312"></a><div align=left><tt>(file-info-socket? <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_314"></a><div align=left><tt>(file-info-special? <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_316"></a><div align=left><tt>(file-info-symlink? <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<p>
The following set of procedures are a convenient means to work on the
permission bits of a file:</p>
<p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_318"></a></p>
<div align=left><tt>(file-not-readable? <i>fname/fd/port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_320"></a><div align=left><tt>(file-not-writable? <i>fname/fd/port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_322"></a><div align=left><tt>(file-not-executable? <i>fname/fd/port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Returns:
<blockquote><table border=0><tr><td valign=top >Value      </td><td valign=top >meaning </td></tr>
<tr><td valign=top ><tt>#f</tt></td><td valign=top >Access permitted </td></tr>
<tr><td valign=top >'search-denied          </td><td valign=top ><table border=0><tr><td valign=top >Can't stat -- a protected directory </td></tr>
<tr><td valign=top >is blocking access.</td></tr></table> </td></tr>
<tr><td valign=top >'permission             </td><td valign=top >Permission denied. </td></tr>
<tr><td valign=top >'no-directory           </td><td valign=top >Some directory doesn't exist. </td></tr>
<tr><td valign=top >'nonexistent            </td><td valign=top >File doesn't exist.
</td></tr></table></blockquote>
A file is considered writeable if either (1) it exists and is writeable
or (2) it doesn't exist and the directory is writeable.
Since symlink permission bits are ignored by the filesystem, these
calls do not take a <i>chase?</i> flag.<p>
Note that these procedures use the process' <em>effective</em> user
and group ids for permission checking. P<small>O</small><small>S</small><small>I</small><small>X</small> defines an <tt><a href="http://www.FreeBSD.org/cgi/man.cgi?query=access&apropos=0&sektion=0&manpath=FreeBSD+4.3-RELEASE&format=html">access()</a></tt>
function that uses the process' real uid and gids. This is handy
for setuid programs that would like to find out if the actual user
has specific rights; scsh ought to provide this functionality (but doesn't
at the current time). </p>
<p>
There are several problems with these procedures. First, there's an
atomicity issue. In between checking permissions for a file and then trying
an operation on the file, another process could change the permissions,
so a return value from these functions guarantees nothing. Second, 
the code special-cases permission checking when the uid is root -- if
the file exists, root is assumed to have the requested permission.
However, not even root can write a file that is on a read-only file system,
such as a CD ROM. In this case, <tt>file-not-writable?</tt> will lie, saying
that root has write access, when in fact the opening the file for write
access will fail.
Finally, write permission confounds write access and create access.
These should be disentangled.</p>
<p>
Some of these problems could be avoided if P<small>O</small><small>S</small><small>I</small><small>X</small> had a real-uid
variant of the <tt><a href="http://www.FreeBSD.org/cgi/man.cgi?query=access&apropos=0&sektion=0&manpath=FreeBSD+4.3-RELEASE&format=html">access()</a></tt> call we could use, but the atomicity
issue is still a problem. In the final analysis, the only way to
find out if you have the right to perform an operation on a file
is to try and open it for the desired operation. These permission-checking
functions are mostly intended for script-writing, where loose guarantees
are tolerated.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_324"></a></p>
<div align=left><tt>(file-readable? <i>fname/fd/port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_326"></a><div align=left><tt>(file-writable? <i>fname/fd/port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_328"></a><div align=left><tt>(file-executable? <i>fname/fd/port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
These procedures are the logical negation of the 
preceding <tt>file-not-<tt>...</tt>?</tt> procedures.
Refer to them for a discussion of their problems and limitations.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_330"></a></p>
<div align=left><tt>(file-info-not-readable? <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_332"></a><div align=left><tt>(file-info-not-writable? <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_334"></a><div align=left><tt>(file-info-not-executable? <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<p></p>
<p></p>
<p><a name="node_idx_336"></a></p>
<div align=left><tt>(file-info-readable? <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_338"></a><div align=left><tt>(file-info-writable? <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_340"></a><div align=left><tt>(file-info-executable? <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<p>
There are variants which work directly on <tt>file-info</tt> records.</p>
<p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_342"></a><div align=left><tt>(file-not-exists? <i>fname/fd/port [chase?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>object</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns:
<blockquote><table border=0><tr><td valign=top ><tt>#f</tt></td><td valign=top >Exists. </td></tr>
<tr><td valign=top ><tt>#t</tt></td><td valign=top >Doesn't exist. </td></tr>
<tr><td valign=top >'search-denied     </td><td valign=top >Some protected directory
is blocking the search.
</td></tr></table></blockquote>
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_344"></a><div align=left><tt>(file-exists? <i>fname/fd/port [chase?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>This is simply
<tt>(not (file-not-exists? <i>fname</i> <i>[chase?]</i>))</tt>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_346"></a></p>
<div align=left><tt>(directory-files <i>[dir dotfiles?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>string list</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Return the list of files in directory <i>dir</i>, 
which defaults to the current working directory.
The <i>dotfiles?</i> flag (default <tt>#f</tt>) causes dot files to be
included in the list.
Regardless of the value of <i>dotfiles?</i>, the two files <tt>.</tt> and
<tt>..</tt> are <em>never</em> returned.<p>
The directory <i>dir</i> is not prepended to each file name in the
result list. That is, 
</p>
<blockquote><tt>(directory-files &quot;/etc&quot;)</tt></blockquote>returns
<blockquote><tt>(&quot;chown&quot; &quot;exports&quot; &quot;fstab&quot; <tt>...</tt>)</tt></blockquote><em>not</em>
<blockquote><tt>(&quot;/etc/chown&quot; &quot;/etc/exports&quot; &quot;/etc/fstab&quot; <tt>...</tt>)</tt></blockquote>To use the files in returned list, the programmer can either manually
prepend the directory:
<blockquote><tt>(map (lambda (f) (string-append dir &quot;/&quot; f)) files)</tt></blockquote>or cd to the directory before using the file names:
<blockquote><tt><br>
(with-cwd&nbsp;dir<br>
&nbsp;&nbsp;(for-each&nbsp;delete-file&nbsp;(directory-files)))</tt></blockquote>
or use the <tt>glob</tt> procedure, defined below.<p>
A directory list can be generated by <tt>(run/strings (ls))</tt>, but this
is unreliable, as filenames with whitespace in their names will be
split into separate entries. Using <tt>directory-files</tt> is reliable.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_348"></a></p>
<div align=left><tt>(open-directory-stream <i>dir</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>directory-stream-record</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<p></p>
<p></p>
<p><a name="node_idx_350"></a></p>
<div align=left><tt>(read-directory-stream <i>directory-stream-record</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>string or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<p></p>
<p></p>
<p><a name="node_idx_352"></a></p>
<div align=left><tt>(close-directory-stream <i>directory-stream-record</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<p>
These functions implement a direct interface to the
<tt><a href="http://www.freebsd.org/cgi/man.cgi?query=opendir&apropos=0&sektion=0&manpath=FreeBSD+4.3-RELEASE&format=html">opendir()</a></tt>/
<tt><a href="http://www.freebsd.org/cgi/man.cgi?query=readdir&apropos=0&sektion=0&manpath=FreeBSD+4.3-RELEASE&format=html">readdir()</a></tt>/
<tt><a href="http://www.freebsd.org/cgi/man.cgi?query=closedir&apropos=0&sektion=0&manpath=FreeBSD+4.3-RELEASE&format=html">closedir()</a></tt>
family of functions for processing directory streams.
<tt>(open-directory-stream dir)</tt> creates a stream of files in the
directory <tt>dir</tt>. <tt>(read-directory-stream directory-stream)</tt>
returns the next file in the stream or <tt>#f</tt>if no such file exists.
Finally, <tt>(close-directory-stream directory-stream)</tt> closes the
stream.</p>
<p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_354"></a></p>
<div align=left><tt>(glob <i><i>pat</i><sub>1</sub> <tt>...</tt></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>string list</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Glob each pattern against the filesystem and return the sorted list. 
Duplicates are not removed. Patterns matching nothing are not included 
literally.<a name="call_footnote_Temp_7"></a><a href="#footnote_Temp_7"><sup><small>5</small></sup></a>
C shell <code class=verbatim>{a,b,c}</code> patterns are expanded. Backslash quotes 
characters, turning off the special meaning of
<code class=verbatim>{</code>, <code class=verbatim>}</code>, <tt>*</tt>, <code class=verbatim>[</code>, <code class=verbatim>]</code>, and <code class=verbatim>?</code>. <p>
Note that the rules of backslash for Scheme strings and glob patterns
work together to require four backslashes in a row to specify a
single literal backslash. Fortunately, it is very rare that a backslash
occurs in a Unix file name.</p>
<p>
A glob subpattern will not match against dot files unless the first
character of the subpattern is a literal ``<tt>.</tt>''. 
Further, a dot subpattern will not match the files <tt>.</tt> or <tt>..</tt> 
unless it is a constant pattern, as in <tt>(glob &quot;../*/*.c&quot;)</tt>.
So a directory's dot files can be reliably generated
with the simple glob pattern <tt>&quot;.*&quot;</tt>.</p>
<p>
Some examples:
</p>
<blockquote>
<pre class=verbatim>(glob &quot;*.c&quot; &quot;*.h&quot;)
    ;; All the C and #include files in my directory.

(glob &quot;*.c&quot; &quot;*/*.c&quot;)
    ;; All the C files in this directory and 
    ;; its immediate subdirectories.

(glob &quot;lexer/*.c&quot; &quot;parser/*.c&quot;)
(glob &quot;{lexer,parser}/*.c&quot;)
    ;; All the C files in the lexer and parser dirs.

(glob &quot;\\{lexer,parser\\}/*.c&quot;)
    ;; All the C files in the strange 
    ;; directory &quot;{lexer,parser}&quot;.

(glob &quot;*\\*&quot;)
    ;; All the files ending in &quot;*&quot;, e.g.
    ;; (&quot;foo*&quot; &quot;bar*&quot;)         

(glob &quot;*lexer*&quot;)
    (&quot;mylexer.c&quot; &quot;lexer1.notes&quot;) 
    ;; All files containing the string &quot;lexer&quot;.

(glob &quot;lexer&quot;)
    ;; Either (&quot;lexer&quot;) or ().</pre><p>
</p>
</blockquote>
If the first character of the pattern (after expanding braces) is a slash,
the search begins at root; otherwise, the search begins in the current
working directory.<p>
If the last character of the pattern (after expanding braces) is a slash,
then the result matches must be directories, <em>e.g.</em>,
</p>
<blockquote><tt><br>
(glob&nbsp;&quot;/usr/man/man?/&quot;)&nbsp;==&gt;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&quot;/usr/man/man1/&quot;&nbsp;&quot;/usr/man/man2/&quot;&nbsp;<tt>...</tt>)</tt></blockquote><p>
Globbing can sometimes be useful when we need a list of a directory's files
where each element in the list includes the pathname for the file.
Compare:
</p>
<blockquote><tt><br>
(directory-files&nbsp;&quot;../include&quot;)&nbsp;==&gt;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;(&quot;cig.h&quot;&nbsp;&quot;decls.h&quot;&nbsp;<tt>...</tt>)<br>
<br>
(glob&nbsp;&quot;../include/*&quot;)&nbsp;==&gt;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;(&quot;../include/cig.h&quot;&nbsp;&quot;../include/decls.h&quot;&nbsp;<tt>...</tt>)</tt></blockquote>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_356"></a></p>
<div align=left><tt>(glob-quote <i>str</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Returns a constant glob pattern that exactly matches <i>str</i>.
All wild-card characters in <i>str</i> are quoted with a backslash.
<blockquote><tt><br>
(glob-quote&nbsp;&quot;Any&nbsp;*.c&nbsp;files?&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;==&gt;&nbsp;&quot;Any&nbsp;\*.c&nbsp;files\?&quot;</tt></blockquote>
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_358"></a><div align=left><tt>(file-match <i>root dot-files? <i>pat</i><sub>1</sub> <i>pat</i><sub>2</sub> <tt>...</tt> <i>pat</i><sub><em>n</em></sub></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>string list</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
{Note This procedure is deprecated, and will probably either go away or
be substantially altered in a future release. New code should not
call this procedure. The problem is that it relies upon
Posix-notation regular expressions; the rest of scsh has been 
converted over to the new SRE notation.}<p>
<tt>file-match</tt> provides a more powerful file-matching service, at the
expense of a less convenient notation. It is intermediate in
power between most shell matching machinery and recursive <tt><a href="http://www.FreeBSD.org/cgi/man.cgi?query=find&apropos=0&sektion=0&manpath=FreeBSD+4.3-RELEASE&format=html">find(1)</a></tt>.</p>
<p>
Each pattern is a regexp. The procedure searches from <i>root</i>,
matching the first-level files against pattern <i>pat</i><sub>1</sub>, the
second-level files against <i>pat</i><sub>2</sub>, and so forth.
The list of files matching the whole path pattern is returned, 
in sorted order.
The matcher uses Spencer's regular expression package.</p>
<p>
The files <tt>.</tt> and <tt>..</tt> are never matched. Other dot files are only
matched if the <i>dot-files?</i> argument is <tt>#t</tt>.</p>
<p>
A given <i>pat</i><sub><em>i</em></sub> pattern is matched as a regexp, so it is not forced
to match the entire file name. <em>E.g.</em>, pattern <tt>&quot;t&quot;</tt> matches any
file containing a ``t'' in its name, while pattern <code class=verbatim>&quot;^t$&quot;</code> matches
only a file whose entire name is ``<tt>t</tt>''.</p>
<p>
The <i>pat</i><sub><em>i</em></sub> patterns can be more general than stated above. 
</p>
<ul>
<li><p>A single pattern can specify multiple levels of the path by
embedding <tt>/</tt> characters within the pattern. For example,
the pattern <tt>&quot;a/b/c&quot;</tt> gives a match equivalent to the
list of patterns <tt>&quot;a&quot; &quot;b&quot; &quot;c&quot;</tt>.</p>
<p>
</p>
<li><p>A <i>pat</i><sub><em>i</em></sub> pattern can be a procedure, 
which is used as a match predicate.
It will be repeatedly called with a candidate file-name to test.
The file-name will be the entire path accumulated.
If the procedure raises an error condition, <tt>file-match</tt> will
catch the error and treat it as a failed match.
This keeps <tt>file-match</tt> from being blown out of the water
by applying tests to dangling symlinks and other similar situations.</p>
<p>
</p>
</ul><p></p>
<p>
Some examples:
</p>
<blockquote>
<blockquote><tt><br>
(file-match&nbsp;&quot;/usr/lib&quot;&nbsp;#f&nbsp;&quot;m$&quot;&nbsp;&quot;^tab&quot;)&nbsp;==&gt;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;(&quot;/usr/lib/term/tab300&quot;&nbsp;&quot;/usr/lib/term/tab300-12&quot;&nbsp;<tt>...</tt>)<br>
[0]<br>
(file-match&nbsp;&quot;.&quot;&nbsp;#f&nbsp;&nbsp;&quot;^lex|parse|codegen$&quot;&nbsp;&quot;\\.c$&quot;)&nbsp;==&gt;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;(&quot;lex/lex.c&quot;&nbsp;&quot;lex/lexinit.c&quot;&nbsp;&quot;lex/test.c&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;parse/actions.c&quot;&nbsp;&quot;parse/error.c&quot;&nbsp;parse/test.c&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;codegen/io.c&quot;&nbsp;&quot;codegen/walk.c&quot;)<br>
[0]<br>
(file-match&nbsp;&quot;.&quot;&nbsp;#f&nbsp;&nbsp;&quot;^lex|parse|codegen$/\\.c$&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;;&nbsp;The&nbsp;same.<br>
[0]<br>
(file-match&nbsp;&quot;.&quot;&nbsp;#f&nbsp;&nbsp;file-directory?)<br>
&nbsp;&nbsp;&nbsp;&nbsp;;;&nbsp;Return&nbsp;all&nbsp;subdirs&nbsp;of&nbsp;the&nbsp;current&nbsp;directory.<br>
[0]<br>
(file-match&nbsp;&quot;/&quot;&nbsp;#f&nbsp;&nbsp;file-directory?)&nbsp;==&gt;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;(&quot;/bin&quot;&nbsp;&quot;/dev&quot;&nbsp;&quot;/etc&quot;&nbsp;&quot;/tmp&quot;&nbsp;&quot;/usr&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;;;&nbsp;All&nbsp;subdirs&nbsp;of&nbsp;root.<br>
[0]<br>
(file-match&nbsp;&quot;.&quot;&nbsp;#f&nbsp;&nbsp;&quot;\\.c&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;;;&nbsp;All&nbsp;the&nbsp;C&nbsp;files&nbsp;in&nbsp;my&nbsp;directory.<br>
[0]<br>
(define&nbsp;(ext&nbsp;extension)<br>
&nbsp;&nbsp;(lambda&nbsp;(fn)&nbsp;(string-suffix?&nbsp;fn&nbsp;extension)))<br>
[0]<br>
(define&nbsp;(true&nbsp;.&nbsp;x)&nbsp;#t)<br>
[0]<br>
(file-match&nbsp;&quot;.&quot;&nbsp;#f&nbsp;&nbsp;&quot;./\\.c&quot;)<br>
(file-match&nbsp;&quot;.&quot;&nbsp;#f&nbsp;&nbsp;&quot;&quot;&nbsp;&quot;\\.c&quot;)<br>
(file-match&nbsp;&quot;.&quot;&nbsp;#f&nbsp;&nbsp;true&nbsp;&quot;\\.c&quot;)<br>
(file-match&nbsp;&quot;.&quot;&nbsp;#f&nbsp;&nbsp;true&nbsp;(ext&nbsp;&quot;c&quot;))<br>
&nbsp;&nbsp;&nbsp;&nbsp;;;&nbsp;All&nbsp;the&nbsp;C&nbsp;files&nbsp;of&nbsp;all&nbsp;my&nbsp;immediate&nbsp;subdirs.<br>
[0]<br>
(file-match&nbsp;&quot;.&quot;&nbsp;#f&nbsp;&quot;lexer&quot;)&nbsp;==&gt;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;(&quot;mylexer.c&quot;&nbsp;&quot;lexer.notes&quot;)&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;;;&nbsp;Compare&nbsp;with&nbsp;(glob&nbsp;&quot;lexer&quot;),&nbsp;above.</tt></blockquote>
</blockquote><p>
Note that when <i>root</i> is the current working directory (<tt>&quot;.&quot;</tt>),
when it is converted to directory form, it becomes <tt>&quot;&quot;</tt>, and doesn't
show up in the result file-names.</p>
<p>
It is regrettable that the regexp wild card char, ``<tt>.</tt>'', 
is such an important file name literal, as dot-file prefix and extension
delimiter.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_360"></a><div align=left><tt>(create-temp-file <i>[prefix]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote><tt>Create-temp-file</tt> creates a new temporary file and return its name.
The optional argument specifies the filename prefix to use, and defaults
to the value of <tt>&quot;<tt>$TMPDIR</tt>/<i>pid</i>&quot;</tt> if <tt>$TMPDIR</tt> is set and to
<tt>&quot;/var/tmp/<i>pid</i>&quot;</tt> otherwise, where <i>pid</i> is the current process' id.
The procedure generates a sequence of filenames that have <i>prefix</i> as
a common prefix, looking for a filename that doesn't already exist in the
file system. When it finds one, it creates it, with permission <tt>#o600</tt>
and returns the filename. (The file permission can be changed to a more
permissive permission with <tt>set-file-mode</tt> after being created).<p>
This file is guaranteed to be brand new. No other process will have it
open. This procedure does not simply return a filename that is very
likely to be unused. It returns a filename that definitely did not exist
at the moment <tt>create-temp-file</tt> created it.</p>
<p>
It is not necessary for the process' pid to be a part of the filename
for the uniqueness guarantees to hold. The pid component of the default
prefix simply serves to scatter the name searches into sparse regions, so
that collisions are less likely to occur. This speeds things up, but does
not affect correctness.</p>
<p>
Security note: doing I/O to files created this way in <tt>/var/tmp/</tt> is
not necessarily secure. General users have write access to <tt>/var/tmp/</tt>,
so even if an attacker cannot access the new temp file, he can delete it
and replace it with one of his own. A subsequent open of this filename
will then give you his file, to which he has access rights. There are
several ways to defeat this attack,
</p>
<ol>
<li><p>Use <tt>temp-file-iterate</tt>, below, to return the file descriptor
allocated when the file is opened. This will work if the file
only needs to be opened once.
</p>
<li><p>If the file needs to be opened twice or more, create it in a 
protected directory, <em>e.g.</em>, <code class=verbatim>$HOME</code>.
</p>
<li><p>Ensure that <tt>/var/tmp</tt> has its sticky bit set. This
requires system administrator privileges.
</p>
</ol><p>
The actual default prefix used is controlled by the dynamic variable
<tt>*temp-file-template*</tt>, and can be overridden for increased security.
See <tt>temp-file-iterate</tt>.
</p>
</blockquote><p>
<a name="node_idx_362"></a></p>
<div align=left><tt>(temp-file-iterate <i>maker [template]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>object</i><sup>+</sup></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
                     
<a name="node_idx_364"></a><div align=left><tt>*temp-file-template*</tt> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>string</i>&nbsp;</div>
<blockquote>
This procedure can be used to perform certain atomic transactions on
the file system involving filenames. Some examples:
<ul>
<li><p>Linking a file to a fresh backup temp name.
</p>
<li><p>Creating and opening an unused, secure temp file.
</p>
<li><p>Creating an unused temporary directory.
</p>
</ul><p></p>
<p>
This procedure uses <i>template</i> to generate a series of trial
file names.  <i>Template</i> is a <tt>format</tt> control string, and
defaults to </p>
<blockquote><tt>&quot;<tt>$TMPDIR</tt>/<i>pid</i>.~a&quot;</tt></blockquote>if <tt>$TMPDIR</tt> is set
and <blockquote><tt>&quot;/var/tmp/<i>pid</i>.~a&quot;</tt></blockquote>otherwise where <i>pid</i> is
the current process' process id.  File names are generated by
calling <tt>format</tt> to instantiate the template's <code class=verbatim>~a</code> field
with a varying string.<p>
<i>Maker</i> is a procedure which is serially called on each file name
generated.  It must return at least one value; it may return multiple
values. If the first return value is <tt>#f</tt> or if <i>maker</i> raises the
<tt>errno/exist</tt> errno exception, <tt>temp-file-iterate</tt> will loop,
generating a new file name and calling <i>maker</i> again. If the first
return value is true, the loop is terminated, returning whatever value(s)
<i>maker</i> returned.</p>
<p>
After a number of unsuccessful trials, <tt>temp-file-iterate</tt> may give up
and signal an error.</p>
<p>
Thus, if we ignore its optional <i>prefix</i> argument, 
<tt>create-temp-file</tt> could be defined as:
</p>
<blockquote><tt><br>
(define&nbsp;(create-temp-file)<br>
&nbsp;&nbsp;(let&nbsp;((flags&nbsp;(bitwise-ior&nbsp;open/create&nbsp;open/exclusive)))<br>
&nbsp;&nbsp;&nbsp;&nbsp;(temp-file-iterate&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(f)&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(close&nbsp;(open-output-file&nbsp;f&nbsp;flags&nbsp;#o600))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f))))</tt></blockquote><p>
To rename a file to a temporary name:
</p>
<blockquote><tt><br>
(temp-file-iterate&nbsp;(lambda&nbsp;(backup)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(create-hard-link&nbsp;old-file&nbsp;backup)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;backup)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;.#temp.~a&quot;)&nbsp;;&nbsp;Keep&nbsp;link&nbsp;in&nbsp;cwd.<br>
(delete-file&nbsp;old-file)</tt></blockquote>
Recall that scsh reports syscall failure by raising an error
exception, not by returning an error code. This is critical to
to this example -- the programmer can assume that if the 
<tt>temp-file-iterate</tt> call returns, it returns successully.
So the following <tt>delete-file</tt> call can be reliably invoked,
safe in the knowledge that the backup link has definitely been established.<p>
To create a unique temporary directory:
</p>
<blockquote><tt><br>
(temp-file-iterate&nbsp;(lambda&nbsp;(dir)&nbsp;(create-directory&nbsp;dir)&nbsp;dir)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;/var/tmp/tempdir.~a&quot;)</tt></blockquote>
Similar operations can be used to generate unique symlinks and fifos,
or to return values other than the new filename (<em>e.g.</em>, an open file
descriptor or port).<p>
The default template is in fact taken from the value of the
dynamic variable <tt>*temp-file-template*</tt>, which itself defaults
to <tt>&quot;<tt>$TMPDIR</tt>/<i>pid</i>.~a&quot;</tt> if <tt>$TMPDIR</tt> is set and
<tt>&quot;/usr/tmp/<i>pid</i>.~a&quot;</tt> otherwise, where <i>pid</i> is the
scsh process' pid.  For increased security, a user may wish to
change the template to use a directory not allowing world write
access (<em>e.g.</em>, his home directory).
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_366"></a></p>
<div align=left><tt>(temp-file-channel<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>[inp outp]</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
This procedure can be used to provide an interprocess communications
channel with arbitrary-sized buffering.  It returns two values, an input
port and an output port, both open on a new temp file.  The temp file
itself is deleted from the Unix file tree before <tt>temp-file-channel</tt>
returns, so the file is essentially unnamed, and its disk storage is
reclaimed as soon as the two ports are closed.<p>
<tt>Temp-file-channel</tt> is analogous to <tt>port-pipe</tt> with two exceptions:
</p>
<ul>
<li><p>If the writer process gets ahead of the reader process, it will
not hang waiting for some small pipe buffer to drain. It will simply
buffer the data on disk. This is good.</p>
<p>
</p>
<li><p>If the reader process gets ahead of the writer process, it will
also not hang waiting for data from the writer process. It will
simply see and report an end of file. This is bad.</p>
<p>
In order to ensure that an end-of-file returned to the reader is
legitimate, the reader and writer must serialise their I/O. The
simplest way to do this is for the reader to delay doing input
until the writer has completely finished doing output, or exited.
</p>
</ul><p>
</p>
</blockquote><p>
</p>
<a name="node_sec_3.4"></a>
<h2><a href="man-Z-H-1.html#node_toc_node_sec_3.4">3.4&nbsp;&nbsp;Processes</a></h2><p></p>
<p></p>
<p></p>
<p><a name="node_idx_368"></a></p>
<div align=left><tt>(exec <i>prog <i>arg</i><sub>1</sub> <tt>...</tt><i>arg</i><sub><em>n</em></sub></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>no return value</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_370"></a><div align=left><tt>(exec-path <i>prog <i>arg</i><sub>1</sub> <tt>...</tt><i>arg</i><sub><em>n</em></sub></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>no return value</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_372"></a><div align=left><tt>(exec/env <i>prog env <i>arg</i><sub>1</sub> <tt>...</tt><i>arg</i><sub><em>n</em></sub></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>no return value</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_374"></a><div align=left><tt>(exec-path/env <i>prog env <i>arg</i><sub>1</sub> <tt>...</tt><i>arg</i><sub><em>n</em></sub></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>no return value</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote><p>
The <tt><tt>...</tt>/env</tt> variants take an environment specified as a 
string-->string alist.
An environment of <tt>#t</tt> is taken to mean the current process' environment 
(<em>i.e.</em>, the value of the external char <tt>**environ</tt>).</p>
<p>
[Rationale: <tt>#f</tt> is a more convenient marker for the current environment
than <tt>#t</tt>, but would cause an ambiguity on Schemes that identify 
<tt>#f</tt> and <tt>()</tt>.]</p>
<p>
The path-searching variants search the directories in the list 
<tt>exec-path-list</tt> for the program.
A path-search is not performed if the program name contains
a slash character -- it is used directly. So a program with a name like
<tt>&quot;bin/prog&quot;</tt> always executes the program <tt>bin/prog</tt> in the current working
directory. See <code class=verbatim>$path</code> and <code class=verbatim>exec-path-list</code>, below.</p>
<p>
Note that there is no analog to the C function <tt><a href="http://www.FreeBSD.org/cgi/man.cgi?query=execv&apropos=0&sektion=0&manpath=FreeBSD+4.3-RELEASE&format=html">execv()</a></tt>.
To get the effect just do
</p>
<blockquote><tt>(apply exec prog arglist)</tt></blockquote><p>
All of these procedures flush buffered output and close unrevealed ports
before executing the new binary.  
To avoid flushing buffered output, see <code class=verbatim>%exec</code> below.</p>
<p>
Note that the C <tt><a href="http://www.FreeBSD.org/cgi/man.cgi?query=exec&apropos=0&sektion=0&manpath=FreeBSD+4.3-RELEASE&format=html">exec()</a></tt> procedure allows the zeroth element of the
argument vector to be different from the file being executed, <em>e.g.</em></p>
<blockquote>
<pre class=verbatim>char *argv[] = {&quot;-&quot;, &quot;-f&quot;, 0};
exec(&quot;/bin/csh&quot;, argv, envp);</pre><p>
</p>
</blockquote>
The scsh <tt>exec</tt>, <tt>exec-path</tt>, <tt>exec/env</tt>, and <tt>exec-path/env</tt>
procedures do not give this functionality -- element 0 of the arg vector is
always identical to the <tt>prog</tt> argument. In the rare case the user wishes
to differentiate these two items, he can use the low-level <code class=verbatim>%exec</code> and
<code class=verbatim>exec-path-search</code> procedures.
These procedures never return under any circumstances.
As with any other system call, if there is an error, they raise
an exception.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_376"></a></p>
<div align=left><tt>(%exec <i>prog arglist env</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_378"></a><div align=left><tt>(exec-path-search <i>fname pathlist</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i> or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
The <tt>%exec</tt> procedure is the low-level interface to the system call.
The <i>arglist</i> parameter is a list of arguments; 
<i>env</i> is either a string-->string alist or <tt>#t</tt>.  
The new program's <tt>argv[0]</tt> will be taken from <tt>(car <i>arglist</i>)</tt>,
<em>not</em> from <i>prog</i>.
An environment of <tt>#t</tt> means the current process' environment. 
<code class=verbatim>%exec</code> does not flush buffered output
(see <tt>flush-all-ports</tt>).<p>
All exec procedures, including <code class=verbatim>%exec</code>, coerce the <tt>prog</tt> and <tt>arg</tt>
values to strings using the usual conversion rules: numbers are converted to
decimal numerals, and symbols converted to their print-names.</p>
<p>
<tt>exec-path-search</tt> searches the directories of <i>pathlist</i> looking for
an occurrence of file <tt>fname</tt>. If no executable file is found, it returns
<tt>#f</tt>. If <tt>fname</tt> contains a slash character, the path search is
short-circuited, but the procedure still checks to ensure that the file exists
and is executable -- if not, it still returns <tt>#f</tt>.
Users of this procedure should be aware that it invites a potential race 
condition: between checking the file with <tt>exec-path-search</tt> and executing
it with <tt>%exec</tt>, the file's status might change.
The only atomic way to do the search is to loop over the candidate
file names, exec'ing each one and looping when the exec operation fails.</p>
<p>
See <tt>$path</tt> and <tt>exec-path-list</tt>, below.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_380"></a></p>
<div align=left><tt>(exit <i>[status]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>no return value</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_382"></a><div align=left><tt>(%exit <i>[status]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>no return value</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
These procedures terminate the current process with a given exit status.
The default exit status is 0.
The low-level <code class=verbatim>%exit</code> procedure immediately terminates the process
without flushing buffered output.
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_384"></a><div align=left><tt>(call-terminally <i>thunk</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>no return value</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote><tt>call-terminally</tt> calls its thunk. When the thunk returns, the process
exits.  Although <tt>call-terminally</tt> could be implemented as
<blockquote><tt>(lambda (thunk) (thunk) (exit 0))</tt></blockquote>an implementation can take advantage of the fact that this procedure never
returns. For example, the runtime can start with a fresh stack and also
start with a fresh dynamic environment, where shadowed bindings are
discarded. This can allow the old stack and dynamic environment to be
collected (assuming this data is not reachable through some live
continuation).
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_386"></a><div align=left><tt>(suspend<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Suspend the current process with a SIGSTOP signal.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_388"></a></p>
<div align=left><tt>(fork <i>[thunk or <tt>#f</tt>] [continue-threads?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>proc or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_390"></a><div align=left><tt>(%fork <i>[thunk or <tt>#f</tt>] [continue-threads?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>proc or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
<tt>fork</tt> with no arguments or <tt>#f</tt> instead of a thunk is like
C
<tt><a href="http://www.FreeBSD.org/cgi/man.cgi?query=fork&apropos=0&sektion=0&manpath=FreeBSD+4.3-RELEASE&format=html">fork()</a></tt>.
In the parent process, it returns the child's <em>process object</em>
(see below for more information on process objects).  In the child
process, it returns <tt>#f</tt>.<p>
<tt>fork</tt> with an argument only returns in the parent process, returning
the child's process object.
The child process calls <i>thunk</i> and then exits.</p>
<p>
<tt>fork</tt> flushes buffered output before forking, and sets the child
process to non-interactive. <code class=verbatim>%fork</code> does not perform this bookkeeping;
it simply forks.</p>
<p>
The optional boolean argument <i>continue-threads?</i> specifies
whether the currently active threads continue to run in the child or
not.  The default is <tt>#f</tt>.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_392"></a></p>
<div align=left><tt>(fork/pipe <i>[thunk] [continue-threads?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>proc or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_394"></a><div align=left><tt>(%fork/pipe <i>[thunk] [continue-threads?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>proc or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Like <tt>fork</tt> and <tt>%fork</tt>, but the parent and child communicate via a
pipe connecting the parent's stdin to the child's stdout. These procedures
side-effect the parent by changing his stdin.<p>
In effect, <tt>fork/pipe</tt> splices a process into the data stream
immediately upstream of the current process.
This is the basic function for creating pipelines.
Long pipelines are built by performing a sequence of <tt>fork/pipe</tt> calls.
For example, to create a background two-process pipe <tt>a | b</tt>, we write:
</p>
<blockquote><tt><br>
(fork&nbsp;(lambda&nbsp;()&nbsp;(fork/pipe&nbsp;a)&nbsp;(b)))</tt></blockquote>
which returns the process object for <tt>b</tt>'s process.<p>
To create a background three-process pipe <tt>a | b | c</tt>, we write:
</p>
<blockquote><tt><br>
(fork&nbsp;(lambda&nbsp;()&nbsp;(fork/pipe&nbsp;a)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fork/pipe&nbsp;b)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(c)))</tt></blockquote>
which returns the process object for <tt>c</tt>'s process.<p>
Note that these procedures affect file descriptors, not ports.
That is, the pipe is allocated connecting the child's file descriptor
1 to the parent's file descriptor 0.
<em>Any previous Scheme port built over these affected file descriptors
is shifted to a new, unused file descriptor with <tt>dup</tt> before
allocating the I/O pipe.</em>
This means, for example, that the ports bound to <tt>(current-input-port)</tt>
and <tt>(current-output-port)</tt> in either process are not affected -- they 
still refer to the same I/O sources and sinks as before.
Remember the simple scsh rule: Scheme ports are bound to I/O sources
and sinks, <em>not</em> particular file descriptors.</p>
<p>
If the child process wishes to rebind the current output port
to the pipe on file descriptor 1, it can do this using 
<tt>with-current-output-port</tt> or a related form.
Similarly, if the parent wishes to change the current input port
to the pipe on file descriptor 0, it can do this using
<tt>set-current-input-port!</tt> or a related form.
Here is an example showing how to set up the I/O ports on both sides
of the pipe:
</p>
<blockquote><tt><br>
(fork/pipe&nbsp;(lambda&nbsp;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-current-output-port&nbsp;(fdes-&gt;outport&nbsp;1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;&quot;Hello,&nbsp;world.\n&quot;))))<br>
<br>
(set-current-input-port!&nbsp;(fdes-&gt;inport&nbsp;0))<br>
(read-line)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;Read&nbsp;the&nbsp;string&nbsp;output&nbsp;by&nbsp;the&nbsp;child.</tt></blockquote>
None of this is necessary when the I/O is performed by an exec'd
program in the child or parent process, only when the pipe will
be referenced by Scheme code through one of the default current I/O
ports.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_396"></a></p>
<div align=left><tt>(fork/pipe+ <i>conns [thunk] [continue-threads?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>proc or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_398"></a><div align=left><tt>(%fork/pipe+ <i>conns [thunk] [continue-threads?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>proc or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Like <tt>fork/pipe</tt>, but the pipe connections between the child and parent
are specified by the connection list <i>conns</i>. 
See the 
<blockquote><tt>(|+ <i>conns</i> <i>pf</i><sub>1</sub> <tt>...</tt> <i>pf</i><sub><em>n</em></sub>)</tt></blockquote>process form for a description of connection lists.
</blockquote><p>
</p>
<a name="node_sec_3.4.1"></a>
<h3><a href="man-Z-H-1.html#node_toc_node_sec_3.4.1">3.4.1&nbsp;&nbsp;Process objects and process reaping</a></h3><p>
Scsh uses <em>process objects</em> to represent Unix processes.
They are created by the <tt>fork</tt> procedure, and have the following
exposed structure:
</p>
<blockquote><tt><br>
(define-record&nbsp;proc<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pid)</tt></blockquote>
<a name="node_idx_400"></a><a name="node_idx_402"></a><a name="node_idx_404"></a>
The only exposed slot in a proc record is the process' pid, 
the integer id assigned by Unix to the process.
The only exported primitive procedures for manipulating process objects
are <tt>proc?</tt> and <tt>proc:pid</tt>.
Process objects are created with the <tt>fork</tt> procedure.<p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_406"></a><div align=left><tt>(pid-&gt;proc <i>pid [probe?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>proc</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
This procedure maps integer Unix process ids to scsh process objects.
It is intended for use in interactive and debugging code, 
and is deprecated for use in production code.
If there is no process object in the system indexed by the given pid,
<tt>pid-&gt;proc</tt>'s action is determined by the <i>probe?</i> parameter
(default <tt>#f</tt>): 
<div align=center><table><tr><td>

<table border=1><tr><td valign=top ><i>probe?</i>    </td><td valign=top >Return                          </td></tr>
<tr><td valign=top ><tt>#f</tt></td><td valign=top ><em>signal error condition.</em>  </td></tr>
<tr><td valign=top ><tt>'create</tt>    </td><td valign=top >Create new proc object.         </td></tr>
<tr><td valign=top >True value      </td><td valign=top ><tt>#f</tt></td></tr>
<tr><td valign=top ></td></tr></table>
</td></tr></table></div>

</blockquote><p>
Sometime after a child process terminates, scsh will perform a <tt>wait</tt>
system call on the child in background, caching the process' exit status
in the child's proc object.
This is called ``reaping'' the process.
Once the child has been waited, the Unix kernel can free the storage allocated
for the dead process' exit information, so process reaping prevents the process
table from becoming cluttered with un-waited dead child processes 
(a.k.a. ``zombies'').
This can be especially severe if the scsh process never waits on child
processes at all; if the process table overflows with forgotten zombies,
the OS may be unable to fork further processes.</p>
<p>
Reaping a child process moves its exit status information from the kernel
into the scsh process, where it is cached inside the child's process object.
If the scsh user drops all pointers to the process object, it will simply be
garbage collected.
On the other hand, if the scsh program retains a pointer to the process object,
it can use scsh's <tt>wait</tt> system call to synchronise with the child and
retrieve its exit status multiple times (this is not possible with simple
Unix integer pids in C -- the programmer can only wait on a pid once).</p>
<p>
Thus, process objects allow scsh programmer to do two things not allowed
in other programming environments:
</p>
<ul>
<li><p>Subprocesses that are never waited on are still removed from the
process table, and their associated exit status data is eventually
automatically garbage collected.
</p>
<li><p>Subprocesses can be waited on multiple times.
</p>
</ul><p></p>
<p>
However, note that once a child has exited, if the scsh programmer
drops all pointers to the child's proc object, the child's exit status
will be reaped and thrown away.
This is the intended behaviour, and it means that integer pids are not
enough to cause a process's exit status to be retained by the scsh runtime.
(This is because it is clearly impossible to GC data referenced by integers.)</p>
<p>
As a convenience for interactive use and debugging, all procedures that
take process objects will also accept integer Unix pids as arguments,
coercing them to the corresponding process objects.
Since integer process ids are not reliable ways to keep a child's exit
status from being reaped and garbage collected, programmers are encouraged
to use process objects in production code.</p>
<p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_408"></a><div align=left><tt>(autoreap-policy <i>[policy]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>old-policy</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
The scsh programmer can choose different policies for automatic
process reaping.
The policy is determined by applying this procedure to one of the
values <tt>'early</tt>, <tt>'late</tt>, or <tt>#f</tt> (<em>i.e.</em>, no autoreap).
<dl><dt></dt><dd>
</dd><dt><b>early</b></dt><dd>
The child is reaped from the Unix kernel's process table
into scsh as soon as it dies. This is done by having a
signal handler for the <tt>SIGCHLD</tt> signal reap the process.<p>
</p>
</dd><dt><b>late</b></dt><dd>
The child is not autoreaped until it dies <em>and</em> the scsh program
drops all pointers to its process object. That is, the process
table is cleaned out during garbage collection.<p>
</p>
</dd><dt><b><tt>#f</tt></b></dt><dd>
If autoreaping is turned off, process reaping is completely under
control of the programmer, who can force outstanding zombies to
be reaped by manually calling the <tt>reap-zombies</tt> procedure
(see below).
</dd></dl><p>
Note that under any of the autoreap policies, a particular process <em>p</em> can
be manually reaped into scsh by simply calling <tt>(wait <em>p</em>)</tt>.
<em>All</em> zombies can be manually reaped with <tt>reap-zombies</tt>.</p>
<p>
The <tt>autoreap-policy</tt> procedure returns the policy's previous value.
Calling <tt>autoreap-policy</tt> with no arguments returns the current
policy without no change.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_410"></a><div align=left><tt>(reap-zombies<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
This procedure reaps all outstanding exited child processes into scsh.
It returns true if there are no more child processes to wait on, and
false if there are outstanding processes still running or suspended.
</blockquote><p>
</p>
<a name="node_sec_3.4.1.1"></a>
<h4><a href="man-Z-H-1.html#node_toc_node_sec_3.4.1.1">3.4.1.1&nbsp;&nbsp;Issues with process reaping</a></h4><p>Reaping a process does not reveal its process group at the time of
death; this information is lost when the process reaped.
This means that a dead, reaped process is <em>not eligible</em> as a return
value for a future <tt>wait-process-group</tt> call.
This is not likely to be a problem for most code, as programs almost
never wait on exited processes by process group.
Process group waiting is usually applied to <em>stopped</em> processes,
which are never reaped. 
So it is unlikely that this will be a problem for most programs.</p>
<p>
</p>
<p>
Automatic process reaping is a useful programming convenience.
However, if a program is careful to wait for all children, and does not wish
automatic reaping to happen, the programmer can simply turn process
autoreaping off.</p>
<p>
Programs that do not wish to use automatic process reaping should be
aware that some scsh routines create subprocesses but do not return
the child's pid: <tt>run/port*</tt>, and its related procedures and
special forms (<tt>run/strings</tt>, <em>et al.</em>).
Automatic process reaping will clean the child processes created by
these procedures out of the kernel's process table.
If a program doesn't use process reaping, it should either avoid these
forms, or use <tt>wait-any</tt> to wait for the children to exit.</p>
<p>
</p>
<a name="node_sec_3.4.2"></a>
<h3><a href="man-Z-H-1.html#node_toc_node_sec_3.4.2">3.4.2&nbsp;&nbsp;Process waiting</a></h3><p></p>
<p></p>
<p></p>
<p><a name="node_idx_412"></a></p>
<div align=left><tt>(wait <i>proc/pid [flags]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>status</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
This procedure waits until a child process exits, and returns its
exit code. The <i>proc/pid</i> argument is either a process object
(section <a href="#node_sec_3.4.1">3.4.1</a>) or an integer process id.
<tt>Wait</tt> returns the child's exit status code (or suspension code,
if the <tt>wait/stopped-children</tt> option is used, see below).
Status values can be queried with the procedures in section 
<a href="#node_sec_3.4.3">3.4.3</a>.<p>
The <i>flags</i> argument is an integer whose bits specify
additional options. It is composed by or'ing together the following
flags:
</p>
<div align=center><table><tr><td>

<table border=1><tr><td valign=top >Flag                    </td><td valign=top >Meaning                           </td></tr>
<tr><td valign=top ><tt>wait/poll</tt>          </td><td valign=top >Return <tt>#f</tt> immediately if
child still active.               </td></tr>
<tr><td valign=top ><tt>wait/stopped-children</tt>      </td><td valign=top >Wait for suspend as well as exit. </td></tr>
<tr><td valign=top ></td></tr></table>
</td></tr></table></div>

</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_414"></a><div align=left><tt>(wait-any <i>[flags]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>[proc status]</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
The optional <i>flags</i> argument is as for <tt>wait</tt>.
This procedure waits for any child process to exit (or stop, if the
<tt>wait/stopped-children</tt> flag is used)
It returns the process' process object and status code.
If there are no children left for which to wait, the two values
<tt>[<tt>#f</tt> <tt>#t</tt>]</tt> are returned.
If the <tt>wait/poll</tt> flag is used, and none of the children
are immediately eligble for waiting, 
then the values <tt>[<tt>#f</tt> <tt>#f</tt>]</tt> are returned:
<div align=center><table><tr><td>

<table border=1><tr><td valign=top >[<tt>#f</tt> <tt>#f</tt>] </td><td valign=top >Poll, none ready </td></tr>
<tr><td valign=top >[<tt>#f</tt> <tt>#t</tt>] </td><td valign=top >No children      </td></tr>
<tr><td valign=top ></td></tr></table>
</td></tr></table></div>
<p>
<tt>Wait-any</tt> will not return a process that has been previously waited
by any other process-wait procedure (<tt>wait</tt>, <tt>wait-any</tt>,
and <tt>wait-process-group</tt>).
It will return reaped processes that haven't yet been waited.</p>
<p>
The use of <tt>wait-any</tt> is deprecated.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_416"></a><div align=left><tt>(wait-process-group <i>proc/pid [flags]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>[proc status]</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
This procedure waits for any child whose process group is <i>proc/pid</i>
(either a process object or a pid).
The <i>flags</i> argument is as for <tt>wait</tt>.<p>
Note that if the programmer wishes to wait for exited processes
by process group, the program should take care not to use process
reaping (section <a href="#node_sec_3.4.1">3.4.1</a>), as this loses
process group information. However, most process-group waiting is
for stopped processes (to implement job control), so this is rarely
an issue, as stopped processes are not subject to reaping.
</p>
</blockquote><p>
</p>
<a name="node_sec_3.4.3"></a>
<h3><a href="man-Z-H-1.html#node_toc_node_sec_3.4.3">3.4.3&nbsp;&nbsp;Analysing process status codes</a></h3><p>
When a child process dies (or is suspended), its parent can call the <tt>wait</tt>
procedure to recover the exit (or suspension) status of the child.
The exit status is a small integer that encodes information
describing how the child terminated.
The bit-level format of the exit status is not defined by P<small>O</small><small>S</small><small>I</small><small>X</small>;
you must use the following three functions to decode one.
However, if a child terminates normally with exit code 0,
P<small>O</small><small>S</small><small>I</small><small>X</small> does require <tt>wait</tt> to return an exit status that is exactly
zero.
So <tt>(zero? <i>status</i>)</tt> is a correct way to test for non-error, 
normal termination, <em>e.g.</em>,
</p>
<blockquote><tt><br>
(if&nbsp;(zero?&nbsp;(run&nbsp;(rcp&nbsp;scsh.tar.gz&nbsp;lambda.csd.hku.hk:)))<br>
&nbsp;&nbsp;&nbsp;&nbsp;(delete-file&nbsp;&quot;scsh.tar.gz&quot;))</tt></blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_418"></a></p>
<div align=left><tt>(status:exit-val <i>status</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>integer</i> or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_420"></a><div align=left><tt>(status:stop-sig <i>status</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>integer</i> or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_422"></a><div align=left><tt>(status:term-sig <i>status</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>integer</i> or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
For a given status value produced by calling <tt>wait</tt>,
exactly one of these routines will return a true value.<p>
If the child process exited normally, <tt>status:exit-val</tt> returns the
exit code for the child process (<em>i.e.</em>, the value the child passed to <tt>exit</tt> 
or returned from <tt>main</tt>). Otherwise, this function returns false.</p>
<p>
If the child process was suspended by a signal, <tt>status:stop-sig</tt>
returns the signal that suspended the child.
Otherwise, this function returns false.</p>
<p>
If the child process terminated abnormally, <tt>status:term-sig</tt>
returns the signal that terminated the child.
Otherwise, this function returns false.
</p>
</blockquote><p>
</p>
<p>
</p>
<p>
</p>
<a name="node_sec_3.5"></a>
<h2><a href="man-Z-H-1.html#node_toc_node_sec_3.5">3.5&nbsp;&nbsp;Process state</a></h2><p></p>
<p></p>
<p></p>
<p><a name="node_idx_424"></a></p>
<div align=left><tt>(umask<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>fixnum</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_426"></a><div align=left><tt>(set-umask <i>perms</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_428"></a><div align=left><tt>(with-umask* <i>perms thunk</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>value(s) of thunk</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_430"></a><div align=left><tt>(with-umask <i>perms . body</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>value(s) of body</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax)&nbsp;</div>

<blockquote>
The process' current umask is retrieved with <tt>umask</tt>, and set with
<tt>(set-umask <i>perms</i>)</tt>. Calling <tt>with-umask*</tt> changes the umask
to <i>perms</i> for the duration of the call to <i>thunk</i>.  If the
program throws out of <i>thunk</i> by invoking a continuation, the umask is
reset to its external value. If the program throws back into <i>thunk</i>
by calling a stored continuation, the umask is restored to the <i>perms</i>
value. The special form <tt>with-umask</tt> is equivalent in effect to
the procedure <tt>with-umask*</tt>, but does not require the programmer
to explicitly wrap a <tt>(lambda () <tt>...</tt>)</tt> around the body of the code
to be executed.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_432"></a></p>
<div align=left><tt>(chdir <i>[fname]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_434"></a><div align=left><tt>(cwd<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_436"></a><div align=left><tt>(with-cwd* <i>fname thunk</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>value(s) of thunk</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_438"></a><div align=left><tt>(with-cwd <i>fname . body</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>value(s) of body</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax)&nbsp;</div>

<blockquote>
These forms manipulate the current working directory.
The cwd can be changed with <tt>chdir</tt> 
(although in most cases, <tt>with-cwd</tt> is preferrable).
If <tt>chdir</tt> is called with no arguments, it changes the cwd to
the user's home directory.
The <tt>with-cwd*</tt> procedure calls <tt>thunk</tt> with the cwd temporarily
set to <i>fname</i>; when <i>thunk</i> returns, or is exited in a non-local
fashion (<em>e.g.</em>, by raising an exception or by invoking a continuation),
the cwd is returned to its original value.
The special form <tt>with-cwd</tt> is simply syntactic sugar for <tt>with-cwd*</tt>.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_440"></a></p>
<div align=left><tt>(pid<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>fixnum</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_442"></a><div align=left><tt>(parent-pid<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>fixnum</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_444"></a><div align=left><tt>(process-group<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>fixnum</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_446"></a><div align=left><tt>(set-process-group <i>[proc/pid] pgrp</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>    
<tt>(pid)</tt> and <tt>(parent-pid)</tt> retrieve the process id for the 
current process and its parent.
<tt>(process-group)</tt> returns the process group of the current process.
A process' process-group can be set with <tt>set-process-group</tt>; 
the value <i>proc/pid</i> specifies the affected process. It may be either
a process object or an integer process id, and defaults to the current
process.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_448"></a></p>
<div align=left><tt>(set-priority <i>which who priority</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_450"></a><div align=left><tt>(priority <i>which who</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>fixnum</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_452"></a><div align=left><tt>(nice <i>[proc/pid delta]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
These procedures set and access the priority of processes. 
I can't remember how <tt>set-priority</tt> and <tt>priority</tt> work, so no
documentation, and besides, they aren't implemented yet, anyway.
</blockquote><p>
<a name="node_idx_454"></a></p>
<div align=left><tt>(user-login-name<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_456"></a><div align=left><tt>(user-uid<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>fixnum</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_458"></a><div align=left><tt>(user-gid<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>fixnum</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_460"></a><div align=left><tt>(user-supplementary-gids<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>fixnum</i> list</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_462"></a><div align=left><tt>(set-uid <i>uid</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_464"></a><div align=left><tt>(set-gid <i>gid</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
These routines get and set the effective and real user and group ids.    
The <tt>set-uid</tt> and <tt>set-gid</tt> routines correspond to the P<small>O</small><small>S</small><small>I</small><small>X</small>
<tt><a href="http://www.FreeBSD.org/cgi/man.cgi?query=setuid&apropos=0&sektion=0&manpath=FreeBSD+4.3-RELEASE&format=html">setuid()</a></tt> and <tt><a href="http://www.FreeBSD.org/cgi/man.cgi?query=setgid&apropos=0&sektion=0&manpath=FreeBSD+4.3-RELEASE&format=html">setgid()</a></tt> procedures.
</blockquote><p>
<a name="node_idx_466"></a></p>
<div align=left><tt>(user-effective-uid<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>fixnum</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_468"></a><div align=left><tt>(set-user-effective-uid <i><i>fixnum</i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_470"></a><div align=left><tt>(with-user-effective-uid* <i><i>fixnum</i> thunk</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>value(s) of thunk</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_472"></a><div align=left><tt>(with-user-effective-uid <i><i>fixnum</i> . body</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>value(s) of body</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax)&nbsp;</div>

<a name="node_idx_474"></a><div align=left><tt>(user-effective-gid<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>fixnum</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_476"></a><div align=left><tt>(set-user-effective-gid <i><i>fixnum</i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_478"></a><div align=left><tt>(with-user-effective-gid* <i><i>fixnum</i> thunk</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>value(s) of thunk</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_480"></a><div align=left><tt>(with-user-effective-gid <i><i>fixnum</i> . body</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>value(s) of body</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax)&nbsp;</div>
<p>
</p>
<blockquote>
These forms manipulate the effective user/group IDs. Possible values
for setting this resource are either the real user/group ID or the
saved set-user/group-ID. The <tt>with-...</tt> forms perform the ususal
temprary assignment during the execution of the second argument. The
effective user and group IDs are thread-local.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_482"></a></p>
<div align=left><tt>(process-times<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>[<i>fixnum</i> <i>fixnum</i> <i>fixnum</i> <i>fixnum</i>]</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Returns four values:
<blockquote>
<div align=left><table><tr><td>

user CPU time in clock-ticks            <br>
system CPU time in clock-ticks          <br>
user CPU time of all descendant processes        <br>
system CPU time of all descendant processes
</td></tr></table></div>

</blockquote>
Note that CPU time clock resolution is not the same as 
the real-time clock resolution provided by <tt>time+ticks</tt>.
That's Unix.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_484"></a></p>
<div align=left><tt>(cpu-ticks/sec<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Returns the resolution of the CPU timer in clock ticks per second.
This can be used to convert the times reported by <tt>process-times</tt>
to seconds.
</blockquote><p>
</p>
<a name="node_sec_3.6"></a>
<h2><a href="man-Z-H-1.html#node_toc_node_sec_3.6">3.6&nbsp;&nbsp;User and group database access</a></h2><p>These procedures are used to access the user and group databases
(<em>e.g.</em>, the ones traditionally stored in <tt>/etc/passwd</tt> and <tt>/etc/group</tt>.)</p>
<p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_486"></a></p>
<div align=left><tt>(user-info <i>uid/name</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>record</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Return a <tt>user-info</tt> record giving the recorded information for a
particular user:
<a name="node_idx_488"></a>
<a name="node_idx_490"></a>
<a name="node_idx_492"></a>
<a name="node_idx_494"></a>
<a name="node_idx_496"></a>
<a name="node_idx_498"></a>
<blockquote><tt><br>
(define-record&nbsp;user-info<br>
&nbsp;&nbsp;name&nbsp;uid&nbsp;gid&nbsp;home-dir&nbsp;shell)</tt></blockquote>
The <i>uid/name</i> argument is either an integer uid or a string user-name.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_500"></a></p>
<div align=left><tt>(-&gt;uid <i>uid/name</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>fixnum</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_502"></a><div align=left><tt>(-&gt;username <i>uid/name</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
These two procedures coerce integer uid's and user names to a particular
form.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_504"></a></p>
<div align=left><tt>(group-info <i>gid/name</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>record</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Return a <tt>group-info</tt> record giving the recorded information for a
particular group:
<a name="node_idx_506"></a>
<a name="node_idx_508"></a>
<a name="node_idx_510"></a>
<a name="node_idx_512"></a>
<blockquote><tt><br>
(define-record&nbsp;group-info<br>
&nbsp;&nbsp;name&nbsp;gid&nbsp;members)</tt></blockquote>
The <i>gid/name</i> argument is either an integer gid or a string group-name.
</blockquote><p>
</p>
<a name="node_sec_3.7"></a>
<h2><a href="man-Z-H-1.html#node_toc_node_sec_3.7">3.7&nbsp;&nbsp;Accessing command-line arguments</a></h2><p></p>
<p></p>
<p></p>
<p><a name="node_idx_514"></a></p>
<div align=left><tt>command-line-arguments</tt> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>string</i> list&nbsp;</div>

<a name="node_idx_516"></a><div align=left><tt>(command-line<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i> list</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
The list of strings <tt>command-line-arguments</tt> contains the arguments
passed to the scsh process on the command line.
Calling <tt>(command-line)</tt> returns the complete <tt>argv</tt>
string list, including the program. So if we run a scsh program
<blockquote><tt>/usr/shivers/bin/myls -CF src</tt></blockquote>then <tt>command-line-arguments</tt> is
<blockquote><tt>(&quot;-CF&quot; &quot;src&quot;)</tt></blockquote>and <tt>(command-line)</tt> returns
<blockquote><tt>(&quot;/usr/shivers/bin/myls&quot; &quot;-CF&quot; &quot;src&quot;)</tt></blockquote><tt>command-line</tt> returns a fresh list each time it is called.
In this way, the programmer can get a fresh copy of the original
argument list if <tt>command-line-arguments</tt> has been modified or is lexically
shadowed.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_518"></a></p>
<div align=left><tt>(arg <i>arglist n [default]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_520"></a><div align=left><tt>(arg* <i>arglist n [default-thunk]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_522"></a><div align=left><tt>(argv <i>n [default]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
These procedures are useful for accessing arguments from argument
lists.
<tt>arg</tt> returns the <em>n</em><sup>th</sup> element of <i>arglist</i>.
The index is 1-based.
If <i>n</i> is too large, <i>default</i> is returned; 
if no <i>default</i>, then an error is signaled.<p>
<tt>arg*</tt> is similar, except that the <i>default-thunk</i> is called to generate
the default value.</p>
<p>
<tt>(argv <i>n</i>)</tt> is simply <tt>(arg (command-line) (+ <i>n</i> 1))</tt>. 
The +1 offset ensures that the two forms
</p>
<blockquote><tt><br>
(arg&nbsp;command-line-arguments&nbsp;<i>n</i>)<br>
(argv&nbsp;<i>n</i>)</tt></blockquote>
return the same argument
(assuming the user has not rebound or modified <tt>command-line-arguments</tt>).<p>
Example:
</p>
<blockquote><tt><br>
(if&nbsp;(null?&nbsp;command-line-arguments)<br>
&nbsp;&nbsp;&nbsp;&nbsp;(&amp;&nbsp;(xterm&nbsp;-n&nbsp;,host&nbsp;-title&nbsp;,host<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-name&nbsp;,(string-append&nbsp;&quot;xterm_&quot;&nbsp;host)))<br>
&nbsp;&nbsp;&nbsp;&nbsp;(let*&nbsp;((progname&nbsp;(file-name-nondirectory&nbsp;(argv&nbsp;1)))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(title&nbsp;(string-append&nbsp;host&nbsp;&quot;:&quot;&nbsp;progname)))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&amp;&nbsp;(xterm&nbsp;-n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,title<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-title&nbsp;,title<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,@command-line-arguments))))</tt></blockquote>
A subtlety: when the scsh interpreter is used to execute a scsh program,
the program name reported in the head of the <tt>(command-line)</tt> list
is the scsh program, <em>not</em> the interpreter.
For example, if we have a shell script in file <tt>fullecho</tt>:
<blockquote><tt><br>
#!/usr/local/bin/scsh&nbsp;-s<br>
!#<br>
(for-each&nbsp;(lambda&nbsp;(arg)&nbsp;(display&nbsp;arg)&nbsp;(display&nbsp;&quot;&nbsp;&quot;))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(command-line))</tt></blockquote>
and we run the program
<blockquote><tt>fullecho hello world</tt></blockquote>the program will print out
<blockquote><tt>fullecho hello world</tt></blockquote>not
<blockquote><tt>/usr/local/bin/scsh -s fullecho hello world</tt></blockquote><p>
This argument line processing ensures that if a scsh program is subsequently
compiled into a standalone executable or byte-compiled to a heap-image
executable by the Scheme 48 virtual machine, its semantics will be
unchanged -- the arglist processing is invariant. In effect, the
</p>
<blockquote><tt>/usr/local/bin/scsh -s</tt></blockquote>is not part of the program; 
it's a specification for the machine to execute the program on, so it is
not properly part of the program's argument list.<p>
</p>
</blockquote><p>
</p>
<a name="node_sec_3.8"></a>
<h2><a href="man-Z-H-1.html#node_toc_node_sec_3.8">3.8&nbsp;&nbsp;System parameters</a></h2><p></p>
<p></p>
<p></p>
<p><a name="node_idx_524"></a></p>
<div align=left><tt>(system-name<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Returns the name of the host on which we are executing.
This may be a local name, such as ``solar,'' as opposed to a
fully-qualified domain name such as ``solar.csie.ntu.edu.tw.''
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_526"></a></p>
<div align=left><tt>(uname<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>uname-record</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Returns a <em>uname-record</em> of the following structure:
<blockquote><tt><br>
(define-record&nbsp;uname<br>
&nbsp;&nbsp;&nbsp;os-name<br>
&nbsp;&nbsp;&nbsp;node-name<br>
&nbsp;&nbsp;&nbsp;release<br>
&nbsp;&nbsp;&nbsp;version<br>
&nbsp;&nbsp;&nbsp;machine)</tt></blockquote><p>
Each of the fields contains a string.</p>
<p>
Be aware that POSIX limits the length of all entries to 32 characters,
and that the node name does not necessarily correspond to the
fully-qualified domain name.
</p>
</blockquote><p>
</p>
<a name="node_sec_3.9"></a>
<h2><a href="man-Z-H-1.html#node_toc_node_sec_3.9">3.9&nbsp;&nbsp;Signal system</a></h2><p>Signal numbers are bound to the variables <tt>signal/hup</tt>, <tt>signal/int</tt>,
<tt>...</tt>. See tables&nbsp;<a href="#node_tbl_Temp_8">3.9.0.1</a> and 
<a href="#node_tbl_Temp_11">3</a> for the full list.</p>
<p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_528"></a></p>
<div align=left><tt>(signal-process <i>proc sig</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_530"></a><div align=left><tt>(signal-process-group <i>prgrp sig</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
These two procedures send signals to a specific process, and all the processes
in a specific process group, respectively.
The <i>proc</i> and <i>prgrp</i> arguments are either processes 
or integer process ids.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_532"></a></p>
<div align=left><tt>(itimer <i>secs</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Schedules a timer interrupt in <i>secs</i> seconds.
</blockquote>
{Note A}s the thread system needs the timer interrupt for its own purpose,
<tt>itimer</tt> works by spawning a thread which calls the interrupt
handler for <tt>interrupt/alrm</tt> after the specified time.
<p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_534"></a></p>
<div align=left><tt>(process-sleep <i>secs</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_536"></a><div align=left><tt>(process-sleep-until <i>time</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
The <tt>sleep</tt> procedure causes the process to sleep for <i>secs</i>
seconds.  The <tt>sleep-until</tt> procedure causes the process to sleep
until <i>time</i> (see section&nbsp;<a href="#node_sec_3.10">3.10</a>).  <p>
{Note The use of these procedures is deprecated as they suspend
<em>all</em> running threads, including the ones Scsh uses for
administrtive purposes. Consider using the <tt>sleep</tt>
procedure from the <tt>thread</tt> package.}
</p>
</blockquote><p>
</p>
<a name="node_sec_3.9.0.1"></a>
<h4><a href="man-Z-H-1.html#node_toc_node_sec_3.9.0.1">3.9.0.1&nbsp;&nbsp;Interrupt handlers</a></h4><p>
Scsh interrupt handlers are complicated by the fact that scsh is implemented on
top of the Scheme 48 virtual machine, which has its own interrupt system, 
independent of the Unix signal system.
This means that Unix signals are delivered in two stages: first,
Unix delivers the signal to the Scheme 48 virtual machine, then
the Scheme 48 virtual machine delivers the signal to the executing Scheme program
as a Scheme 48 interrupt.
This ensures that signal delivery happens between two vm instructions,
keeping individual instructions atomic.</p>
<p>
The Scheme 48 machine has its own set of interrupts, which includes the
asynchronous Unix signals (table&nbsp;<a href="#node_tbl_Temp_8">3.9.0.1</a>).
</p>
<p></p>
<hr>
<p></p>
<a name="node_tbl_Temp_8"></a>
<div class=table align=center><table width=100%><tr><td align=center></td><td><div align=left>
<div align=center><table><tr><td>

<table border=0><tr><td valign=top >Interrupt </td><td valign=top >Unix signal </td><td valign=top >OS Variant </td></tr>
<tr><td valign=top ><a name="node_idx_538"></a><tt>interrupt/alrm</tt><a name="call_footnote_Temp_9"></a><a href="#footnote_Temp_9"><sup><small>6</small></sup></a>
</td><td valign=top ><a name="node_idx_542"></a><tt>signal/alrm</tt>     </td><td valign=top >P<small>O</small><small>S</small><small>I</small><small>X</small></td></tr>
<tr><td valign=top ><a name="node_idx_544"></a><tt>interrupt/int</tt><a name="call_footnote_Temp_10"></a><a href="#footnote_Temp_10"><sup><small>7</small></sup></a>
</td><td valign=top ><a name="node_idx_548"></a><tt>signal/int</tt>      </td><td valign=top >P<small>O</small><small>S</small><small>I</small><small>X</small></td></tr>
<tr><td valign=top ><a name="node_idx_550"></a><tt>interrupt/memory-shortage</tt> </td><td valign=top >N/A                   </td><td valign=top ></td></tr>
<tr><td valign=top ><a name="node_idx_552"></a><tt>interrupt/chld</tt>            </td><td valign=top ><a name="node_idx_554"></a><tt>signal/chld</tt>    </td><td valign=top >P<small>O</small><small>S</small><small>I</small><small>X</small></td></tr>
<tr><td valign=top ><a name="node_idx_556"></a><tt>interrupt/cont</tt>            </td><td valign=top ><a name="node_idx_558"></a><tt>signal/cont</tt>    </td><td valign=top >P<small>O</small><small>S</small><small>I</small><small>X</small></td></tr>
<tr><td valign=top ><a name="node_idx_560"></a><tt>interrupt/hup</tt>             </td><td valign=top ><a name="node_idx_562"></a><tt>signal/hup</tt>     </td><td valign=top >P<small>O</small><small>S</small><small>I</small><small>X</small></td></tr>
<tr><td valign=top ><a name="node_idx_564"></a><tt>interrupt/quit</tt>            </td><td valign=top ><a name="node_idx_566"></a><tt>signal/quit</tt>    </td><td valign=top >P<small>O</small><small>S</small><small>I</small><small>X</small></td></tr>
<tr><td valign=top ><a name="node_idx_568"></a><tt>interrupt/term</tt>            </td><td valign=top ><a name="node_idx_570"></a><tt>signal/term</tt>    </td><td valign=top >P<small>O</small><small>S</small><small>I</small><small>X</small></td></tr>
<tr><td valign=top ><a name="node_idx_572"></a><tt>interrupt/tstp</tt>            </td><td valign=top ><a name="node_idx_574"></a><tt>signal/tstp</tt>    </td><td valign=top >P<small>O</small><small>S</small><small>I</small><small>X</small></td></tr>
<tr><td valign=top ><a name="node_idx_576"></a><tt>interrupt/usr1</tt>            </td><td valign=top ><a name="node_idx_578"></a><tt>signal/usr1</tt>    </td><td valign=top >P<small>O</small><small>S</small><small>I</small><small>X</small></td></tr>
<tr><td valign=top ><a name="node_idx_580"></a><tt>interrupt/usr2</tt>            </td><td valign=top ><a name="node_idx_582"></a><tt>signal/usr2</tt>    </td><td valign=top >P<small>O</small><small>S</small><small>I</small><small>X</small></td></tr>
<tr><td valign=top ></td></tr>
<tr><td valign=top ><a name="node_idx_584"></a><tt>interrupt/info</tt>            </td><td valign=top ><a name="node_idx_586"></a><tt>signal/info</tt>    </td><td valign=top >BSD only   </td></tr>
<tr><td valign=top ><a name="node_idx_588"></a><tt>interrupt/io</tt>              </td><td valign=top ><a name="node_idx_590"></a><tt>signal/io</tt>      </td><td valign=top >BSD + SVR4 </td></tr>
<tr><td valign=top ><a name="node_idx_592"></a><tt>interrupt/poll</tt>            </td><td valign=top ><a name="node_idx_594"></a><tt>signal/poll</tt>    </td><td valign=top >SVR4 only  </td></tr>
<tr><td valign=top ><a name="node_idx_596"></a><tt>interrupt/prof</tt>            </td><td valign=top ><a name="node_idx_598"></a><tt>signal/prof</tt>    </td><td valign=top >BSD + SVR4 </td></tr>
<tr><td valign=top ><a name="node_idx_600"></a><tt>interrupt/pwr</tt>             </td><td valign=top ><a name="node_idx_602"></a><tt>signal/pwr</tt>     </td><td valign=top >SVR4 only  </td></tr>
<tr><td valign=top ><a name="node_idx_604"></a><tt>interrupt/urg</tt>             </td><td valign=top ><a name="node_idx_606"></a><tt>signal/urg</tt>     </td><td valign=top >BSD + SVR4 </td></tr>
<tr><td valign=top ><a name="node_idx_608"></a><tt>interrupt/vtalrm</tt>          </td><td valign=top ><a name="node_idx_610"></a><tt>signal/vtalrm</tt>  </td><td valign=top >BSD + SVR4 </td></tr>
<tr><td valign=top ><a name="node_idx_612"></a><tt>interrupt/winch</tt>           </td><td valign=top ><a name="node_idx_614"></a><tt>signal/winch</tt>   </td><td valign=top >BSD + SVR4 </td></tr>
<tr><td valign=top ><a name="node_idx_616"></a><tt>interrupt/xcpu</tt>            </td><td valign=top ><a name="node_idx_618"></a><tt>signal/xcpu</tt>    </td><td valign=top >BSD + SVR4 </td></tr>
<tr><td valign=top ><a name="node_idx_620"></a><tt>interrupt/xfsz</tt>            </td><td valign=top ><a name="node_idx_622"></a><tt>signal/xfsz</tt>     </td><td valign=top >BSD + SVR4 </td></tr>
<tr><td valign=top ></td></tr></table>
</td></tr></table></div>

</td></tr>
<tr><td align=center><b>Table 2:</b>&nbsp;&nbsp;Scheme 48 virtual-machine interrupts and related Unix signals.
Only the P<small>O</small><small>S</small><small>I</small><small>X</small> signals are guaranteed to be defined; however,
your implementation and OS may define other signals and
interrupts not listed here.</td></tr>
<tr><td>
</div></td><td>

</td></tr></table></div><p></p>
<hr>
<p></p>
<p>
</p>
<p></p>
<hr>
<p></p>
<a name="node_tbl_Temp_11"></a>
<div class=table align=center><table width=100%><tr><td align=center><div align=center><table><tr><td>

<table border=0><tr><td valign=top >Unix signal </td><td valign=top >Type </td><td valign=top >OS Variant </td></tr>
<tr><td valign=top ><a name="node_idx_624"></a><tt>signal/stop</tt>       </td><td valign=top >Uncatchable   </td><td valign=top >P<small>O</small><small>S</small><small>I</small><small>X</small></td></tr>
<tr><td valign=top ><a name="node_idx_626"></a><tt>signal/kill</tt>       </td><td valign=top >Uncatchable   </td><td valign=top >P<small>O</small><small>S</small><small>I</small><small>X</small></td></tr>
<tr><td valign=top ></td></tr>
<tr><td valign=top ><a name="node_idx_628"></a><tt>signal/abrt</tt>       </td><td valign=top >Synchronous   </td><td valign=top >P<small>O</small><small>S</small><small>I</small><small>X</small></td></tr>
<tr><td valign=top ><a name="node_idx_630"></a><tt>signal/fpe</tt>        </td><td valign=top >Synchronous   </td><td valign=top >P<small>O</small><small>S</small><small>I</small><small>X</small></td></tr>
<tr><td valign=top ><a name="node_idx_632"></a><tt>signal/ill</tt>        </td><td valign=top >Synchronous   </td><td valign=top >P<small>O</small><small>S</small><small>I</small><small>X</small></td></tr>
<tr><td valign=top ><a name="node_idx_634"></a><tt>signal/pipe</tt>       </td><td valign=top >Synchronous   </td><td valign=top >P<small>O</small><small>S</small><small>I</small><small>X</small></td></tr>
<tr><td valign=top ><a name="node_idx_636"></a><tt>signal/segv</tt>       </td><td valign=top >Synchronous   </td><td valign=top >P<small>O</small><small>S</small><small>I</small><small>X</small></td></tr>
<tr><td valign=top ><a name="node_idx_638"></a><tt>signal/ttin</tt>       </td><td valign=top >Synchronous   </td><td valign=top >P<small>O</small><small>S</small><small>I</small><small>X</small></td></tr>
<tr><td valign=top ><a name="node_idx_640"></a><tt>signal/ttou</tt>       </td><td valign=top >Synchronous   </td><td valign=top >P<small>O</small><small>S</small><small>I</small><small>X</small></td></tr>
<tr><td valign=top ></td></tr>
<tr><td valign=top ><a name="node_idx_642"></a><tt>signal/bus</tt>        </td><td valign=top >Synchronous   </td><td valign=top >BSD + SVR4 </td></tr>
<tr><td valign=top ><a name="node_idx_644"></a><tt>signal/emt</tt>        </td><td valign=top >Synchronous   </td><td valign=top >BSD + SVR4 </td></tr>
<tr><td valign=top ><a name="node_idx_646"></a><tt>signal/iot</tt>        </td><td valign=top >Synchronous   </td><td valign=top >BSD + SVR4 </td></tr>
<tr><td valign=top ><a name="node_idx_648"></a><tt>signal/sys</tt>        </td><td valign=top >Synchronous   </td><td valign=top >BSD + SVR4 </td></tr>
<tr><td valign=top ><a name="node_idx_650"></a><tt>signal/trap</tt>       </td><td valign=top >Synchronous   </td><td valign=top >BSD + SVR4 </td></tr>
<tr><td valign=top ></td></tr></table>
</td></tr></table></div>

</td></tr>
<tr><td align=center><b>Table 3:</b>&nbsp;&nbsp;Uncatchable and synchronous Unix signals. While these signals
may be sent with <tt>signal-process</tt> or 
<tt>signal-process-group</tt>,
there are no corresponding scsh interrupt handlers.
Only the P<small>O</small><small>S</small><small>I</small><small>X</small> signals are guaranteed to be defined; however,
your implementation and OS may define other signals not listed
here.</td></tr>
<tr><td>

</td></tr></table></div><p></p>
<hr>
<p></p>
<p>
Note that scsh does <em>not</em> support signal handlers for
``synchronous'' Unix signals, such as <tt>signal/ill</tt> or
<tt>signal/pipe</tt> (see table&nbsp;<a href="#node_tbl_Temp_11">3</a>).
Synchronous occurrences of these signals are better handled by raising
a Scheme exception.  We recommend you avoid using signal handlers
unless you absolutely have to; Section <a href="man-Z-H-10.html#node_sec_9.4">9.4</a>
describes a better interface to signals.
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_652"></a><div align=left><tt>(signal-&gt;interrupt <i><i>integer</i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
The programmer maps from Unix signals to Scheme 48 interrupts with the
<tt>signal-&gt;interrupt</tt> procedure.
If the signal does not have a defined Scheme 48 interrupt, an errror is signaled.
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_654"></a><div align=left><tt>(interrupt-set <i><i><i>integer</i><sub>1</sub> <tt>...</tt><i>integer</i><sub><em>n</em></sub></i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
This procedure builds interrupt sets from its interrupt arguments.
A set is represented as an integer using a two's-complement representation of
the bit set.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_656"></a></p>
<div align=left><tt>(enabled-interrupts<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>interrupt-set</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_658"></a><div align=left><tt>(set-enabled-interrupts <i>interrupt-set</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>interrupt-set</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Get and set the value of the enabled-interrupt set.
Only interrupts in this set have their handlers called when delivered.
When a disabled interrupt is delivered to the Scheme 48 machine, it is
held pending until it becomes enabled, at which time its handler is invoked.<p>
Interrupt sets are represented as integer bit sets (constructed with
the <tt>interrupt-set</tt> function).
The <tt>set-enabled-interrupts</tt> procedure returns the previous value of
the enabled-interrupt set.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_660"></a></p>
<div align=left><tt>(with-enabled-interrupts <i>interrupt-set . body</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>value(s) of body</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax)&nbsp;</div>

<a name="node_idx_662"></a><div align=left><tt>(with-enabled-interrupts* <i>interrupt-set thunk</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>value(s) of thunk</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Run code with a given set of interrupts enabled.
Note that ``enabling'' an interrupt means enabling delivery from
the Scheme 48 vm to the scsh program.
Using the Scheme 48 interrupt system is fairly lightweight, and does not involve
actually making a system call.
Note that enabling an interrupt means that the assigned interrupt handler
is allowed to run when the interrupt is delivered.
Interrupts not enabled are held pending when delivered.<p>
Interrupt sets are represented as integer bit sets (constructed with
the <tt>interrupt-set</tt> function).
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_664"></a><div align=left><tt>(set-interrupt-handler <i>interrupt handler</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>old-handler</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Assigns a handler for a given interrupt, 
and returns the interrupt's old handler.
The <i>handler</i> argument is <tt>#f</tt> (ignore), <tt>#t</tt> (default), or a
procedure taking an integer argument; 
the return value follows the same conventions.
Note that the <i>interrupt</i> argument is an interrupt value, 
not a signal value.
An interrupt is delivered to the Scheme 48 machine by (1) blocking all interrupts,
and (2) applying the handler procedure to the set of interrupts 
that were enabled prior to the interrupt delivery.
If the procedure returns normally (<em>i.e.</em>, it doesn't throw to a continuation), 
the set of enabled interrupts will be returned to its previous value.
(To restore the enabled-interrupt set before throwing out of an interrupt
handler, see <tt>set-enabled-interrupts</tt>)<p>
{Note If you set a handler for the <tt>interrupt/chld</tt> interrupt,
you may break scsh's autoreaping process machinery. See the
discussion of autoreaping in section&nbsp;<a href="#node_sec_3.4.1">3.4.1</a>.}
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_666"></a><div align=left><tt>(interrupt-handler <i>interrupt</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>handler</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Return the handler for a given interrupt.
Note that the argument is an interrupt value, not a signal value.
A handler is either <tt>#f</tt> (ignore), <tt>#t</tt> (default), or a
procedure taking an integer argument.
</blockquote><p>
</p>
<p>
</p>
<a name="node_sec_3.10"></a>
<h2><a href="man-Z-H-1.html#node_toc_node_sec_3.10">3.10&nbsp;&nbsp;Time</a></h2><p></p>
<p>
Scsh's time system is fairly sophisticated, particularly with respect
to its careful treatment of time zones.
However, casual users shouldn't be intimidated;
all of the complexity is optional, 
and defaulting all the optional arguments reduces the system
to a simple interface.</p>
<p>
</p>
<a name="node_sec_3.10.1"></a>
<h3><a href="man-Z-H-1.html#node_toc_node_sec_3.10.1">3.10.1&nbsp;&nbsp;Terminology</a></h3><p>``UTC'' and ``UCT'' stand for ``universal coordinated time,'' which is the 
official name for what is colloquially referred to as ``Greenwich Mean
Time.''</p>
<p>
P<small>O</small><small>S</small><small>I</small><small>X</small> allows a single time zone to specify <em>two</em> different offsets
from UTC: one standard one, and one for ``summer time.''
Summer time is frequently some sort of daylight savings time. </p>
<p>
The scsh time package consistently uses this terminology: we never say
``gmt'' or ``dst;'' we always say ``utc'' and ``summer time.''</p>
<p>
</p>
<a name="node_sec_3.10.2"></a>
<h3><a href="man-Z-H-1.html#node_toc_node_sec_3.10.2">3.10.2&nbsp;&nbsp;Basic data types</a></h3><p>We have two types: <em>time</em> and <em>date</em>.</p>
<p>
<a name="node_idx_668"></a>
A <em>time</em> specifies an instant in the history of the universe.
It is location and time-zone independent.<a name="call_footnote_Temp_12"></a><a href="#footnote_Temp_12"><sup><small>8</small></sup></a>
A time is a real value
giving the number of elapsed seconds since the Unix ``epoch''
(Midnight, January 1, 1970 UTC).
Time values provide arbitrary time resolution,
limited only by the number system of the underlying Scheme system.</p>
<p>
<a name="node_idx_670"></a>
A <em>date</em> is a name for an instant in time that is specified
relative to some location/time-zone in the world, <em>e.g.</em>:
</p>
<blockquote>
Friday October 31, 1994 3:47:21 pm EST.
</blockquote>
Dates provide one-second resolution, 
and are expressed with the following record type:
<blockquote><tt><a name="node_idx_672"></a><br>
(define-record&nbsp;date&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;A&nbsp;Posix&nbsp;tm&nbsp;struct<br>
&nbsp;&nbsp;seconds&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;Seconds&nbsp;after&nbsp;the&nbsp;minute&nbsp;[0-59]<br>
&nbsp;&nbsp;minute&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;Minutes&nbsp;after&nbsp;the&nbsp;hour&nbsp;[0-59]<br>
&nbsp;&nbsp;hour&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;Hours&nbsp;since&nbsp;midnight&nbsp;[0-23]<br>
&nbsp;&nbsp;month-day&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;Day&nbsp;of&nbsp;the&nbsp;month&nbsp;[1-31]<br>
&nbsp;&nbsp;month&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;Months&nbsp;since&nbsp;January&nbsp;[0-11]<br>
&nbsp;&nbsp;year&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;Years&nbsp;since&nbsp;1900<br>
&nbsp;&nbsp;tz-name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;Time-zone&nbsp;name:&nbsp;#f&nbsp;or&nbsp;a&nbsp;string.<br>
&nbsp;&nbsp;tz-secs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;Time-zone&nbsp;offset:&nbsp;#f&nbsp;or&nbsp;an&nbsp;integer.<br>
&nbsp;&nbsp;summer?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;Summer&nbsp;(Daylight&nbsp;Savings)&nbsp;time&nbsp;in&nbsp;effect?<br>
&nbsp;&nbsp;week-day&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;Days&nbsp;since&nbsp;Sunday&nbsp;[0-6]<br>
&nbsp;&nbsp;year-day)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;Days&nbsp;since&nbsp;Jan.&nbsp;1&nbsp;[0-365]</tt></blockquote>
If the <tt>tz-secs</tt> field is given, it specifies the time-zone's offset from
UTC in seconds. If it is specified, the <tt>tz-name</tt> and <tt>summer?</tt>
fields are ignored when using the date structure to determine a specific
instant in time.<p>
If the <tt>tz-name</tt> field is given, it is a time-zone string such as 
<tt>&quot;EST&quot;</tt> or <tt>&quot;HKT&quot;</tt> understood by the OS.
Since P<small>O</small><small>S</small><small>I</small><small>X</small> time-zone strings can specify dual standard/summer time-zones
(e.g., &quot;EST5EDT&quot; specifies U.S. Eastern Standard/Eastern Daylight Time),
the value of the <tt>summer?</tt> field is used to resolve the amiguous
boundary cases. For example, on the morning of the Fall daylight savings
change-over, 1:00am-2:00am happens twice. Hence the date 1:30 am
on this morning can specify two different seconds; 
the <tt>summer?</tt> flag says which one.</p>
<p>
A date with <tt>tz-name</tt>  =  <tt>tz-secs</tt>  =  <tt>#f</tt> is a date that
is specified in terms of the system's current time zone.</p>
<p>
There is redundancy in the <tt>date</tt> data structure.
For example, the <tt>year-day</tt> field is redundant
with the <tt>month-day</tt> and <tt>month</tt> fields.
Either of these implies the values of the <tt>week-day</tt> field.
The <tt>summer?</tt> and <tt>tz-name</tt> fields are redundant with the <tt>tz-secs</tt>
field in terms of specifying an instant in time.
This redundancy is provided because consumers of dates may want it broken out
in different ways.
The scsh procedures that produce date records fill them out completely.
However, when date records produced by the programmer are passed to
scsh procedures, the redundancy is resolved by ignoring some of the
secondary fields. 
This is described for each procedure below.</p>
<p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_674"></a></p>
<div align=left><tt>(make-date <i>s min h mday mon y [tzn tzs summ? wday yday]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>date</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
When making a <tt>date</tt> record, the last five elements of the record
are optional, and default to <tt>#f</tt>, <tt>#f</tt>, <tt>#f</tt>, 0, 
and 0 respectively.
This is useful when creating a <tt>date</tt> record to pass as an
argument to <tt>time</tt>. Other procedures, however, may refuse to work
with these incomplete <tt>date</tt> records.
</blockquote><p>
</p>
<a name="node_sec_3.10.3"></a>
<h3><a href="man-Z-H-1.html#node_toc_node_sec_3.10.3">3.10.3&nbsp;&nbsp;Time zones</a></h3><p>Several time procedures take time zones as arguments. When optional,
the time zone defaults to local time zone. Otherwise the time zone
can be one of:
</p>
<blockquote>
<table border=0><tr><td valign=top ><tt>#f</tt>        </td><td valign=top >Local time </td></tr>
<tr><td valign=top >Integer         </td><td valign=top >Seconds of offset from UTC. For example,
New York City is -18000 (-5 hours), San Francisco
is -28800 (-8 hours). </td></tr>
<tr><td valign=top >String          </td><td valign=top >A P<small>O</small><small>S</small><small>I</small><small>X</small> time zone string understood by the OS
(<em>i.e.</em>., the sort of time zone assigned to the <tt>$TZ</tt>
environment variable).
</td></tr></table>
</blockquote>
An integer time zone gives the number of seconds you must add to UTC 
to get time in that zone. It is <em>not</em> ``seconds west'' of UTC -- that
flips the sign.<p>
To get UTC time, use a time zone of either 0 or <tt>&quot;UCT0&quot;</tt>.</p>
<p>
</p>
<a name="node_sec_3.10.4"></a>
<h3><a href="man-Z-H-1.html#node_toc_node_sec_3.10.4">3.10.4&nbsp;&nbsp;Procedures</a></h3><p></p>
<p></p>
<p></p>
<p><a name="node_idx_676"></a></p>
<div align=left><tt>(time+ticks<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>[secs ticks]</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_678"></a><div align=left><tt>(ticks/sec<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>real</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
The current time, with sub-second resolution.
Sub-second resolution is not provided by P<small>O</small><small>S</small><small>I</small><small>X</small>,
but is available on many systems.
The time is returned as elapsed seconds since the Unix epoch, plus
a number of sub-second ``ticks.''
The length of a tick may vary from implementation to implementation;
it can be determined from <tt>(ticks/sec)</tt>.<p>
The system clock is not required to report time at the full resolution
given by <tt>(ticks/sec)</tt>. For example, on BSD, time is reported at
1&micro;s resolution, so <tt>(ticks/sec)</tt> is 1,000,000. That doesn't mean
the system clock has micro-second resolution.</p>
<p>
If the OS does not support sub-second resolution, the <i>ticks</i> value
is always 0, and <tt>(ticks/sec)</tt> returns 1.</p>
<p>
</p>
<blockquote><i>Remark: </i>
I chose to represent system clock resolution as ticks/sec
instead of sec/tick to increase the odds that the value could
be represented as an exact integer, increasing efficiency and
making it easier for Scheme implementations that don't have
sophisticated numeric support to deal with the quantity.<p>
You can convert seconds and ticks to seconds with the expression
</p>
<blockquote><tt>(+ <i>secs</i> (/ <i>ticks</i> (ticks/sec)))</tt></blockquote>Given that, why not have the fine-grain time procedure just
return a non-integer real for time? Following Common Lisp, I chose to
allow the system clock to report sub-second time in its own units to
lower the overhead of determining the time.  This would be important
for a system that wanted to precisely time the duration of some
event. Time stamps could be collected with little overhead, deferring
the overhead of precisely calculating with them until after collection.<p>
This is all a bit academic for the Scheme 48 implementation, where
we determine time with a heavyweight system call, but it's nice
to plan for the future.
</p>
</blockquote>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_680"></a></p>
<div align=left><tt>(date<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>date-record</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_682"></a><div align=left><tt>(date <i>[time tz]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>date-record</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Simple <tt>(date)</tt> returns the current date, in the local time zone.<p>
With the optional arguments, <tt>date</tt> converts the time to the date as
specified by the time zone <i>tz</i>.
<i>Time</i> defaults to the current time; <i>tz</i> defaults to local time, 
and is as described in the time-zone section.</p>
<p>
If the <i>tz</i> argument is an integer, the date's <tt>tz-name</tt>
field is a P<small>O</small><small>S</small><small>I</small><small>X</small> time zone of the form
``<tt>UTC+<em>hh</em>:<em>mm</em>:<em>ss</em></tt>''; 
the trailing <tt>:<em>mm</em>:<em>ss</em></tt> portion is deleted if it is zeroes.</p>
<p>
</p>
<blockquote><i>Oops: </i> The Posix facility for converting dates to times, <tt><a href="http://www.FreeBSD.org/cgi/man.cgi?query=mktime&apropos=0&sektion=0&manpath=FreeBSD+4.3-RELEASE&format=html">mktime()</a></tt>,
has a broken design: it indicates an error by returning -1, which
is also a legal return value (for date 23:59:59 UCT, 12/31/1969).
Scsh resolves the ambiguity in a paranoid fashion: it always
reports an error if the underlying Unix facility returns -1.
We feel your pain.
</blockquote>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_684"></a></p>
<div align=left><tt>(time<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_686"></a><div align=left><tt>(time <i>[date]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Simple <tt>(time)</tt> returns the current time.<p>
With the optional date argument, <tt>time</tt> converts a date to a time.
<i>Date</i> defaults to the current date.</p>
<p>
Note that the input <i>date</i> record is overconstrained.
<tt>time</tt> ignores <i>date</i>'s <tt>week-day</tt> and <tt>year-day</tt> fields. 
If the date's <tt>tz-secs</tt> field is set, the <tt>tz-name</tt> and
<tt>summer?</tt> fields are ignored.</p>
<p>
If the <tt>tz-secs</tt> field is <tt>#f</tt>, then the time-zone is taken
from the <tt>tz-name</tt> field. A false <tt>tz-name</tt> means the system's
current time zone. When calculating with time-zones, the date's
<tt>summer?</tt> field is used to resolve ambiguities:
</p>
<blockquote>
<table border=0><tr><td valign=top ><tt>#f</tt> </td><td valign=top >Resolve an ambiguous time in favor of non-summer time. </td></tr>
<tr><td valign=top >true     </td><td valign=top >Resolve an ambiguous time in favor of summer time.
</td></tr></table>
</blockquote>
This is useful in boundary cases during the change-over. For example,
in the Fall, when US daylight savings time changes over at 2:00 am,
1:30 am happens twice -- it names two instants in time, an hour apart.<p>
Outside of these boundary cases, the <tt>summer?</tt> flag is ignored. For
example, if the standard/summer change-overs happen in the Fall and the
Spring, then the value of <tt>summer?</tt> is ignored for a January or 
July date. A January date would be resolved with standard time, and a 
July date with summer time, regardless of the <tt>summer?</tt> value.</p>
<p>
The <tt>summer?</tt> flag is also ignored if the time zone doesn't have 
a summer time -- for example, simple UTC.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_688"></a></p>
<div align=left><tt>(date-&gt;string <i>date</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_690"></a><div align=left><tt>(format-date <i>fmt date</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
<tt>Date-&gt;string</tt> formats the date as a 24-character string of the
form:
<blockquote>
Sun Sep 16 01:03:52 1973            
</blockquote><p>
<tt>Format-date</tt> formats the date according to the format string
<i>fmt</i>. The format string is copied verbatim, except that tilde
characters indicate conversion specifiers that are replaced by fields from
the date record.  Figure <a href="#node_fig_Temp_13">1</a> gives the full set of
conversion specifiers supported by <tt>format-date</tt>.</p>
<p>
</p>
<p></p>
<hr>
<p></p>
<a name="node_fig_Temp_13"></a>
<div class=figure align=center><table width=100%><tr><td align=center>

<table border=0><tr><td valign=top ><code class=verbatim>~~</code> </td><td valign=top >Converted to the <code class=verbatim>~</code> character. </td></tr>
<tr><td valign=top ><code class=verbatim>~a</code> </td><td valign=top >abbreviated weekday name </td></tr>
<tr><td valign=top ><code class=verbatim>~A</code> </td><td valign=top >full weekday name </td></tr>
<tr><td valign=top ><code class=verbatim>~b</code> </td><td valign=top >abbreviated month name </td></tr>
<tr><td valign=top ><code class=verbatim>~B</code> </td><td valign=top >full month name </td></tr>
<tr><td valign=top ><code class=verbatim>~c</code> </td><td valign=top >time and date using the time and date representation 
for the locale (<code class=verbatim>~X ~x</code>) </td></tr>
<tr><td valign=top ><code class=verbatim>~d</code> </td><td valign=top >day of the month as a decimal number (01-31) </td></tr>
<tr><td valign=top ><code class=verbatim>~H</code> </td><td valign=top >hour based on a 24-hour clock
as a decimal number (00-23) </td></tr>
<tr><td valign=top ><code class=verbatim>~I</code> </td><td valign=top >hour based on a 12-hour clock
as a decimal number (01-12) </td></tr>
<tr><td valign=top ><code class=verbatim>~j</code> </td><td valign=top >day of the year as a decimal number (001-366) </td></tr>
<tr><td valign=top ><code class=verbatim>~m</code> </td><td valign=top >month as a decimal number (01-12) </td></tr>
<tr><td valign=top ><code class=verbatim>~M</code> </td><td valign=top >minute as a decimal number (00-59) </td></tr>
<tr><td valign=top ><code class=verbatim>~p</code> </td><td valign=top >AM/PM designation associated with a 12-hour clock </td></tr>
<tr><td valign=top ><code class=verbatim>~S</code> </td><td valign=top >second as a decimal number (00-61) </td></tr>
<tr><td valign=top ><code class=verbatim>~U</code> </td><td valign=top >week number of the year; 
Sunday is first day of week (00-53) </td></tr>
<tr><td valign=top ><code class=verbatim>~w</code> </td><td valign=top >weekday as a decimal number (0-6), where Sunday is 0 </td></tr>
<tr><td valign=top ><code class=verbatim>~W</code> </td><td valign=top >week number of the year;
Monday is first day of week (00-53) </td></tr>
<tr><td valign=top ><code class=verbatim>~x</code> </td><td valign=top >date using the date representation for the locale </td></tr>
<tr><td valign=top ><code class=verbatim>~X</code> </td><td valign=top >time using the time representation for the locale </td></tr>
<tr><td valign=top ><code class=verbatim>~y</code> </td><td valign=top >year without century (00-99) </td></tr>
<tr><td valign=top ><code class=verbatim>~Y</code> </td><td valign=top >year with century (<em>e.g.</em>1990) </td></tr>
<tr><td valign=top ><code class=verbatim>~Z</code> </td><td valign=top >time zone name or abbreviation, or no characters
if no time zone is determinable
</td></tr></table><p>
</p>
</td></tr>
<tr><td align=center><b>Figure 1:</b>&nbsp;&nbsp;<tt>format-date</tt> conversion specifiers</td></tr>
<tr><td>

</td></tr></table></div><p></p>
<hr>
<p></p>
<p>
</p>
</blockquote><p>
</p>
<p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_692"></a></p>
<div align=left><tt>(fill-in-date! <i>date</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>date</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
This procedure fills in missing, redundant slots in a date record.
In decreasing order of priority:
<ul>
<li><p><strong>year, month, month-day ==&gt; year-day</strong><br>

If the <tt>year</tt>, <tt>month</tt>, and <tt>month-day</tt> fields are all
defined (are all integers), the <tt>year-day</tt>
field is set to the corresponding value.
</p>
<li><p><strong>year, year-day ==&gt; month, month-day</strong><br>

If the <tt>month</tt> and <tt>month-day</tt> fields aren't set, but
the <tt>year</tt> and <tt>year-day</tt> fields are set, then
<tt>month</tt> and <tt>month-day</tt> are calculated.
</p>
<li><p><strong>year, month, month-day, year-day ==&gt; week-day</strong><br>

If either of the above rules is able to determine what day it is,
the <tt>week-day</tt> field is then set.
</p>
<li><p><strong>tz-secs ==&gt; tz-name</strong><br>

If <tt>tz-secs</tt> is defined, but <tt>tz-name</tt> is not, it is assigned
a time-zone name of the form ``<tt>UTC+<em>hh</em>:<em>mm</em>:<em>ss</em></tt>''; 
the trailing <tt>:<em>mm</em>:<em>ss</em></tt> portion is deleted if it 
is zeroes.
</p>
<li><p><strong>tz-name, date, summer? ==&gt; tz-secs, summer?</strong><br>

If the date information is provided up to second resolution,
<tt>tz-name</tt> is also provided, and <tt>tz-secs</tt> is not set,
then <tt>tz-secs</tt> and <tt>summer?</tt> are set to their correct values. 
Summer-time ambiguities are resolved using the original value of
<tt>summer?</tt>. If the time zone doesn't have a
summer time variant, then <tt>summer?</tt> is set to <tt>#f</tt>.
</p>
<li><p><strong>local time, date, summer? ==&gt; tz-name, tz-secs, summer?</strong><br>

If the date information is provided up to second resolution,
but no time zone information is provided (both <tt>tz-name</tt> and
<tt>tz-secs</tt> aren't set), then we proceed as in the above case,
except the system's current time zone is used.
</p>
</ul><p>
These rules allow one particular ambiguity to escape:
if both <tt>tz-name</tt> and <tt>tz-secs</tt> are set, they are not brought
into agreement. It isn't clear how to do this, nor is it clear which
one should take precedence.</p>
<p>
</p>
<blockquote><i>Oops: </i> <tt>fill-in-date!</tt> isn't implemented  yet.</blockquote><p>
</p>
</blockquote><p>
</p>
<a name="node_sec_3.11"></a>
<h2><a href="man-Z-H-1.html#node_toc_node_sec_3.11">3.11&nbsp;&nbsp;Environment variables</a></h2><p></p>
<p></p>
<p></p>
<p><a name="node_idx_694"></a></p>
<div align=left><tt>(setenv <i>var val</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_696"></a><div align=left><tt>(getenv <i>var</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
These functions get and set the process environment, stored in the
external C variable <tt>char **environ</tt>.
An environment variable <i>var</i> is a string.
If an environment variable is set to a string <i>val</i>, 
then the process' global environment structure is altered with an entry 
of the form <tt>&quot;<i>var</i>=<i>val</i>&quot;</tt>.
If <i>val</i> is <tt>#f</tt>, then any entry for <i>var</i> is deleted.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_698"></a></p>
<div align=left><tt>(env-&gt;alist<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i>--><i>string</i> alist</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
The <tt>env-&gt;alist</tt> procedure converts the entire environment into
an alist, <em>e.g.</em>,
<blockquote><tt><br>
((&quot;TERM&quot;&nbsp;.&nbsp;&quot;vt100&quot;)<br>
&nbsp;(&quot;SHELL&quot;&nbsp;.&nbsp;&quot;/usr/local/bin/scsh&quot;)&nbsp;<br>
&nbsp;(&quot;PATH&quot;&nbsp;.&nbsp;&quot;/sbin:/usr/sbin:/bin:/usr/bin&quot;)<br>
&nbsp;(&quot;EDITOR&quot;&nbsp;.&nbsp;&quot;emacs&quot;)&nbsp;<br>
&nbsp;<tt>...</tt>)</tt></blockquote>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_700"></a></p>
<div align=left><tt>(alist-&gt;env <i>alist</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
<i>Alist</i> must be an alist whose keys are all strings, and whose values
are all either strings or string lists. String lists are converted to
colon lists (see below). The alist is installed as the current Unix
environment (<em>i.e.</em>, converted to a null-terminated C vector of
<tt>&quot;<i>var</i>=<i>val</i>&quot;</tt> strings which is assigned to the global
<tt>char **environ</tt>).<p>
</p>
<blockquote><tt><br>
;;;&nbsp;Note&nbsp;$PATH&nbsp;entry&nbsp;is&nbsp;converted&nbsp;<br>
;;;&nbsp;to&nbsp;/sbin:/usr/sbin:/bin:/usr/bin.<br>
(alist-&gt;env&nbsp;'((&quot;TERM&quot;&nbsp;.&nbsp;&quot;vt100&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&quot;PATH&quot;&nbsp;&quot;/sbin&quot;&nbsp;&quot;/usr/sbin&quot;&nbsp;&quot;/bin&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&quot;SHELL&quot;&nbsp;.&nbsp;&quot;/usr/local/bin/scsh&quot;)))<br>
</tt></blockquote><p>
Note that <tt>env-&gt;alist</tt> and <tt>alist-&gt;env</tt> are not exact 
inverses -- <tt>alist-&gt;env</tt> will convert a list value into a single
colon-separated string, but <tt>env-&gt;alist</tt> will not parse colon-separated
values into lists. (See the <tt>$PATH</tt> element in the examples given for
each procedure.)</p>
<p>
</p>
</blockquote><p>
The following three functions help the programmer manipulate alist
tables in some generally useful ways. They are all defined using
<tt>equal?</tt> for key comparison.</p>
<p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_702"></a><div align=left><tt>(alist-delete <i>key alist</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>alist</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Delete any entry labelled by value <i>key</i>.
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_704"></a><div align=left><tt>(alist-update <i>key val alist</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>alist</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Delete <i>key</i> from <i>alist</i>, then cons on a
<tt>(<i>key</i> . <i>val</i>)</tt> entry.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_706"></a></p>
<div align=left><tt>(alist-compress <i>alist</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>alist</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Compresses <i>alist</i> by removing shadowed entries.
Example:
<blockquote><tt><br>
;;;&nbsp;Shadowed&nbsp;(1&nbsp;.&nbsp;c)&nbsp;entry&nbsp;removed.<br>
(alist-compress&nbsp;'(&nbsp;(1&nbsp;.&nbsp;a)&nbsp;(2&nbsp;.&nbsp;b)&nbsp;(1&nbsp;.&nbsp;c)&nbsp;(3&nbsp;.&nbsp;d)&nbsp;))<br>
&nbsp;&nbsp;&nbsp;&nbsp;==&gt;&nbsp;&nbsp;((1&nbsp;.&nbsp;a)&nbsp;(2&nbsp;.&nbsp;b)&nbsp;(3&nbsp;.&nbsp;d))</tt></blockquote>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_708"></a></p>
<div align=left><tt>(with-env* <i>env-alist-delta thunk</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>value(s) of thunk</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_710"></a><div align=left><tt>(with-total-env* <i>env-alist thunk</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>value(s) of thunk</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
These procedures call <i>thunk</i> in the context of an altered
environment. They return whatever values <i>thunk</i> returns.
Non-local returns restore the environment to its outer value;
throwing back into the thunk by invoking a stored continuation
restores the environment back to its inner value.<p>
The <i>env-alist-delta</i> argument specifies
a <em>modification</em> to the current environment -- <i>thunk</i>'s
environment is the original environment overridden with the
bindings specified by the alist delta.</p>
<p>
The <i>env-alist</i> argument specifies a complete environment
that is installed for <i>thunk</i>.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_712"></a></p>
<div align=left><tt>(with-env <i>env-alist-delta . body</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>value(s) of body</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax)&nbsp;</div>

<a name="node_idx_714"></a><div align=left><tt>(with-total-env <i>env-alist . body</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>value(s) of body</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax)&nbsp;</div>

<blockquote>
These special forms provide syntactic sugar for <tt>with-env*</tt>
and <tt>with-total-env*</tt>. 
The env alists are not evaluated positions, but are implicitly backquoted.
In this way, they tend to resemble binding lists for <tt>let</tt> and
<tt>let*</tt> forms.
</blockquote><p>
Example: These four pieces of code all run the mailer with special 
<tt>$TERM</tt> and <tt>$EDITOR</tt> values.
</p>
<blockquote><tt><br>
(with-env&nbsp;((&quot;TERM&quot;&nbsp;.&nbsp;&quot;xterm&quot;)&nbsp;(&quot;EDITOR&quot;&nbsp;.&nbsp;,my-editor))<br>
&nbsp;&nbsp;(run&nbsp;(mail&nbsp;shivers@lcs.mit.edu)))<br>
[0]<br>
(with-env*&nbsp;`((&quot;TERM&quot;&nbsp;.&nbsp;&quot;xterm&quot;)&nbsp;(&quot;EDITOR&quot;&nbsp;.&nbsp;,my-editor))<br>
&nbsp;&nbsp;(lambda&nbsp;()&nbsp;(run&nbsp;(mail&nbsp;shivers@csd.hku.hk))))<br>
[0]<br>
(run&nbsp;(begin&nbsp;(setenv&nbsp;&quot;TERM&quot;&nbsp;&quot;xterm&quot;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;Env&nbsp;mutation&nbsp;happens<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(setenv&nbsp;&quot;EDITOR&quot;&nbsp;my-editor)&nbsp;;&nbsp;in&nbsp;the&nbsp;subshell.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(exec-epf&nbsp;(mail&nbsp;shivers@research.att.com))))<br>
[0]<br>
;;&nbsp;In&nbsp;this&nbsp;example,&nbsp;we&nbsp;compute&nbsp;an&nbsp;alternate&nbsp;environment&nbsp;ENV2<br>
;;&nbsp;as&nbsp;an&nbsp;alist,&nbsp;and&nbsp;install&nbsp;it&nbsp;with&nbsp;an&nbsp;explicit&nbsp;call&nbsp;to&nbsp;the<br>
;;&nbsp;EXEC-PATH/ENV&nbsp;procedure.<br>
(let*&nbsp;((env&nbsp;(env-&gt;alist))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;Get&nbsp;the&nbsp;current&nbsp;environment,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(env1&nbsp;(alist-update&nbsp;env&nbsp;&nbsp;&quot;TERM&quot;&nbsp;&quot;xterm&quot;))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;and&nbsp;compute<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(env2&nbsp;(alist-update&nbsp;env1&nbsp;&quot;EDITOR&quot;&nbsp;my-editor)))&nbsp;;&nbsp;the&nbsp;new&nbsp;env.<br>
&nbsp;&nbsp;(run&nbsp;(begin&nbsp;(exec-path/env&nbsp;&quot;mail&quot;&nbsp;env2&nbsp;&quot;shivers@cs.cmu.edu&quot;))))</tt></blockquote><p>
</p>
<a name="node_sec_3.11.1"></a>
<h3><a href="man-Z-H-1.html#node_toc_node_sec_3.11.1">3.11.1&nbsp;&nbsp;Path lists and colon lists</a></h3><p>When environment variables such as <tt>$PATH</tt> need to encode a list of
strings (such as a list of directories to be searched), 
the common Unix convention is to separate the list elements with 
colon delimiters.<a name="call_footnote_Temp_14"></a><a href="#footnote_Temp_14"><sup><small>9</small></sup></a>
To convert between the colon-separated string encoding and the
list-of-strings representation, see the <tt>infix-splitter</tt> function
(section&nbsp;<a href="man-Z-H-9.html#node_sec_8.1.2">8.1.2</a>) and the string library's
<tt>string-join</tt> function.
For example,
</p>
<blockquote><tt><br>
(define&nbsp;split&nbsp;(infix-splitter&nbsp;(rx&nbsp;&quot;:&quot;)))<br>
(split&nbsp;&quot;/sbin:/bin::/usr/bin&quot;)&nbsp;==&gt;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;'(&quot;/sbin&quot;&nbsp;&quot;/bin&quot;&nbsp;&quot;&quot;&nbsp;&quot;/usr/bin&quot;)<br>
(string-join&nbsp;&quot;:&quot;&nbsp;'(&quot;/sbin&quot;&nbsp;&quot;/bin&quot;&nbsp;&quot;&quot;&nbsp;&quot;/usr/bin&quot;))&nbsp;==&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;/sbin:/bin::/usr/bin&quot;</tt></blockquote>
The following two functions are useful for manipulating these ordered lists,
once they have been parsed from their colon-separated form.<p>
</p>
<p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_716"></a></p>
<div align=left><tt>(add-before <i>elt before list</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>list</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_718"></a><div align=left><tt>(add-after <i>elt after list</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>list</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
These functions are for modifying search-path lists, where element order
is significant.<p>
<tt>add-before</tt> adds <i>elt</i> to the list immediately
before the first occurrence of <i>before</i> in the list.
If <i>before</i> is not in the list, <i>elt</i> is added to the end
of the list.</p>
<p>
<tt>add-after</tt> is similar:
<i>elt</i> is added after the last occurrence of <i>after</i>.
If <i>after</i> is not found, 
<i>elt</i> is added to the beginning of the list.</p>
<p>
Neither function destructively alters the original path-list.
The result may share structure with the original list.
Both functions use <tt>equal?</tt> for comparing elements.
</p>
</blockquote><p>
</p>
<a name="node_sec_3.11.2"></a>
<h3><a href="man-Z-H-1.html#node_toc_node_sec_3.11.2">3.11.2&nbsp;&nbsp;<tt>$USER</tt>, <tt>$HOME</tt>, and <tt>$PATH</tt></a></h3><p>Like sh and unlike csh, scsh has <em>no</em> interactive dependencies on
environment variables.
It does, however, initialise certain internal values at startup time from the
initial process environment, in particular <tt>$HOME</tt> and <tt>$PATH</tt>.
Scsh never uses <tt>$USER</tt> at all.
It computes <tt>(user-login-name)</tt> from the system call <tt>(user-uid)</tt>.</p>
<p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_720"></a></p>
<div align=left><tt>home-directory</tt> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>string</i>&nbsp;</div>
<a name="node_idx_722"></a><div align=left><tt>exec-path-list</tt> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>string</i> list thread-fluid&nbsp;</div>

<blockquote>
Scsh accesses <tt>$HOME</tt> at start-up time, and stores the value in the
global variable <tt>home-directory</tt>. It uses this value for <tt>~</tt>
lookups and for returning to home on <tt>(chdir)</tt>.<p>
Scsh accesses <tt>$PATH</tt> at start-up time, colon-splits the path list, and
stores the value in the thread fluid <tt>exec-path-list</tt>. This list is
used for <tt>exec-path</tt> and <tt>exec-path/env</tt> searches.</p>
<p>
To access, rebind or side-effect thread-fluid cells, you must open
the <tt>thread-fluids</tt> package.
</p>
</blockquote><p>
</p>
<p>
</p>
<a name="node_sec_3.12"></a>
<h2><a href="man-Z-H-1.html#node_toc_node_sec_3.12">3.12&nbsp;&nbsp;Terminal device control</a></h2><p></p>
<p>
</p>
<p>
Scsh provides a complete set of routines for manipulating terminal
devices -- putting them in ``raw'' mode, changing and querying their
special characters, modifying their I/O speeds, and so forth.
The scsh interface is designed both for generality and portability
across different Unix platforms, so you don't have to rewrite your
program each time you move to a new system.
We've also made an effort to use reasonable, Scheme-like names for
the multitudinous named constants involved, so when you are reading
code, you'll have less likelihood of getting lost in a bewildering
maze of obfuscatory constants named <tt>ICRNL</tt>, <tt>INPCK</tt>, <tt>IUCLC</tt>,
and <tt>ONOCR</tt>.</p>
<p>
This section can only lay out the basic functionality of the terminal
device interface.
For further details, see the termios(3) man page on your system,
or consult one of the standard Unix texts.</p>
<p>
</p>
<a name="node_sec_3.12.1"></a>
<h3><a href="man-Z-H-1.html#node_toc_node_sec_3.12.1">3.12.1&nbsp;&nbsp;Portability across OS variants</a></h3><p>Terminal-control software is inescapably complex, ugly, and low-level.
Unix variants each provide their own way of controlling terminal
devices, making it difficult to provide interfaces that are
portable across different Unix systems.
Scsh's terminal support is based primarily upon the P<small>O</small><small>S</small><small>I</small><small>X</small> termios
interface.
Programs that can be written using only the P<small>O</small><small>S</small><small>I</small><small>X</small> interface are likely
to be widely portable.</p>
<p>
The bulk of the documentation that follows consists of several pages worth
of tables defining different named constants that enable and disable different
features of the terminal driver.
Some of these flags are P<small>O</small><small>S</small><small>I</small><small>X</small>; others are taken from the two common
branches of Unix development, SVR4 and 4.3+ Berkeley.
Scsh guarantees that the non-P<small>O</small><small>S</small><small>I</small><small>X</small> constants will be bound identifiers.
</p>
<ul>
<li><p>If your OS supports a particular non-P<small>O</small><small>S</small><small>I</small><small>X</small> flag, 
its named constant will be bound to the flag's value.
</p>
<li><p>If your OS doesn't support the flag, its named constant
will be present, but bound to <tt>#f</tt>.
</p>
</ul><p>
This means that if you want to use SVR4 or Berkeley features in a program,
your program can portably test the values of the flags before using 
them -- the flags can reliably be referenced without producing OS-dependent
``unbound variable'' errors.</p>
<p>
Finally, note that although P<small>O</small><small>S</small><small>I</small><small>X</small>, SVR4, and Berkeley cover the lion's
share of the terminal-driver functionality, 
each operating system inevitably has non-standard extensions.
While a particular scsh implementation may provide these extensions,
they are not portable, and so are not documented here.</p>
<p>
</p>
<a name="node_sec_3.12.2"></a>
<h3><a href="man-Z-H-1.html#node_toc_node_sec_3.12.2">3.12.2&nbsp;&nbsp;Miscellaneous procedures</a></h3><p></p>
<p></p>
<p></p>
<p><a name="node_idx_724"></a></p>
<div align=left><tt>(tty? <i>fd/port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Return true if the argument is a tty.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_726"></a></p>
<div align=left><tt>(tty-file-name <i>fd/port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
The argument <i>fd/port</i> must be a file descriptor or port open on a tty.
Return the file-name of the tty.
</blockquote><p>
</p>
<a name="node_sec_3.12.3"></a>
<h3><a href="man-Z-H-1.html#node_toc_node_sec_3.12.3">3.12.3&nbsp;&nbsp;The tty-info record type</a></h3><p>The primary data-structure that describes a terminal's mode is
a <tt>tty-info</tt> record, defined as follows:
<a name="node_idx_728"></a>
<a name="node_idx_730"></a>
<a name="node_idx_732"></a>
<a name="node_idx_734"></a>
<a name="node_idx_736"></a>
<a name="node_idx_738"></a>
<a name="node_idx_740"></a>
<a name="node_idx_742"></a>
<a name="node_idx_744"></a>
<a name="node_idx_746"></a>
<a name="node_idx_748"></a>
</p>
<blockquote><tt><br>
(define-record&nbsp;tty-info<br>
&nbsp;&nbsp;control-chars&nbsp;&nbsp;;&nbsp;String:&nbsp;Magic&nbsp;input&nbsp;chars<br>
&nbsp;&nbsp;input-flags&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;Int:&nbsp;Input&nbsp;processing<br>
&nbsp;&nbsp;output-flags&nbsp;&nbsp;&nbsp;;&nbsp;Int:&nbsp;Output&nbsp;processing<br>
&nbsp;&nbsp;control-flags&nbsp;&nbsp;;&nbsp;Int:&nbsp;Serial-line&nbsp;control<br>
&nbsp;&nbsp;local-flags&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;Int:&nbsp;Line-editting&nbsp;UI<br>
&nbsp;&nbsp;input-speed&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;Int:&nbsp;Code&nbsp;for&nbsp;input&nbsp;speed<br>
&nbsp;&nbsp;output-speed&nbsp;&nbsp;&nbsp;;&nbsp;Int:&nbsp;Code&nbsp;for&nbsp;output&nbsp;speed<br>
&nbsp;&nbsp;min&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;Int:&nbsp;Raw-mode&nbsp;input&nbsp;policy<br>
&nbsp;&nbsp;time)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;Int:&nbsp;Raw-mode&nbsp;input&nbsp;policy</tt></blockquote><p>
</p>
<a name="node_sec_3.12.3.1"></a>
<h4><a href="man-Z-H-1.html#node_toc_node_sec_3.12.3.1">3.12.3.1&nbsp;&nbsp;The control-characters string</a></h4><p>The <tt>control-chars</tt> field is a character string;
its characters may be indexed by integer values taken from 
table&nbsp;<a href="#node_tbl_Temp_16">4</a>.</p>
<p>
As discussed above, 
only the P<small>O</small><small>S</small><small>I</small><small>X</small> entries in table&nbsp;<a href="#node_tbl_Temp_16">4</a> are guaranteed
to be legal, integer indices.
A program can reliably test the OS to see if the non-P<small>O</small><small>S</small><small>I</small><small>X</small> 
characters are supported by checking the index constants.
If the control-character function is supported by the terminal driver, 
then the corresponding index will be bound to an integer;
if it is not supported, the index will be bound to <tt>#f</tt>.</p>
<p>
To disable a given control-character function, set its corresponding
entry in the <tt>tty-info:control-chars</tt> string to the
special character <a name="node_idx_750"></a><tt>disable-tty-char</tt> 
(and then use the <tt>(set-tty-info <i>fd/port</i> <i>info</i>)</tt> procedure
to update the terminal's state).</p>
<p>
</p>
<a name="node_sec_3.12.3.2"></a>
<h4><a href="man-Z-H-1.html#node_toc_node_sec_3.12.3.2">3.12.3.2&nbsp;&nbsp;The flag fields</a></h4><p>The <tt>tty-info</tt> record's <tt>input-flags</tt>, <tt>output-flags</tt>,
<tt>control-flags</tt>, and <tt>local-flags</tt> fields are all bit sets
represented as two's-complement integers.
Their values are composed by or'ing together values taken from
the named constants listed in tables&nbsp;<a href="#node_tbl_Temp_17">5</a> 
through <a href="#node_tbl_Temp_22">9</a>.</p>
<p>
As discussed above, 
only the P<small>O</small><small>S</small><small>I</small><small>X</small> entries listed in these tables are guaranteed
to be legal, integer flag values.
A program can reliably test the OS to see if the non-P<small>O</small><small>S</small><small>I</small><small>X</small> 
flags are supported by checking the named constants.
If the feature is supported by the terminal driver, 
then the corresponding flag will be bound to an integer;
if it is not supported, the flag will be bound to <tt>#f</tt>.</p>
<p>
</p>
<p>
</p>
<p>
</p>
<a name="node_sec_3.12.3.3"></a>
<h4><a href="man-Z-H-1.html#node_toc_node_sec_3.12.3.3">3.12.3.3&nbsp;&nbsp;The speed fields</a></h4><p>The <tt>input-speed</tt> and <tt>output-speed</tt> fields determine the
I/O rate of the terminal's line.
The value of these fields is an integer giving the speed
in bits-per-second.
The following speeds are supported by P<small>O</small><small>S</small><small>I</small><small>X</small>:
</p>
<div align=center><table><tr><td>

<table border=0><tr><td valign=top >0        </td><td valign=top >134 </td><td valign=top >600  </td><td valign=top >4800  </td></tr>
<tr><td valign=top >50       </td><td valign=top >150 </td><td valign=top >1200 </td><td valign=top >9600  </td></tr>
<tr><td valign=top >75       </td><td valign=top >200 </td><td valign=top >1800 </td><td valign=top >19200 </td></tr>
<tr><td valign=top >110      </td><td valign=top >300 </td><td valign=top >2400 </td><td valign=top >38400 </td></tr>
<tr><td valign=top ></td></tr></table>
</td></tr></table></div>

Your OS may accept others; it may also allow the special symbols
<tt>'exta</tt> and <tt>'extb</tt>.<p>
</p>
<a name="node_sec_3.12.3.4"></a>
<h4><a href="man-Z-H-1.html#node_toc_node_sec_3.12.3.4">3.12.3.4&nbsp;&nbsp;The min and time fields</a></h4><p>The integer <tt>min</tt> and <tt>time</tt> fields determine input blocking
behaviour during non-canonical (raw) input; otherwise, they are ignored.
See the termios(3) man page for further details.</p>
<p>
Be warned that P<small>O</small><small>S</small><small>I</small><small>X</small> allows the base system call's representation
of the <tt>tty-info</tt> record to share storage for the <tt>min</tt> field
and the <tt>ttychar/eof</tt> element of the control-characters string,
and for the <tt>time</tt> field and the <tt>ttychar/eol</tt> element
of the control-characters string.
Many implementations in fact do this.</p>
<p>
To stay out of trouble, set the <tt>min</tt> and <tt>time</tt> fields only
if you are putting the terminal into raw mode;
set the eof and eol control-characters only if you are putting
the terminal into canonical mode.
It's ugly, but it's Unix.</p>
<p>
</p>
<a name="node_sec_3.12.4"></a>
<h3><a href="man-Z-H-1.html#node_toc_node_sec_3.12.4">3.12.4&nbsp;&nbsp;Using tty-info records</a></h3><p></p>
<p></p>
<p></p>
<p><a name="node_idx_752"></a></p>
<div align=left><tt>(make-tty-info <i>if of cf lf ispeed ospeed min time</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>tty-info-record</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_754"></a><div align=left><tt>(copy-tty-info <i>tty-info-record</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>tty-info-record</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
These procedures make it possible to create new <tt>tty-info</tt> records.
The typical method for creating a new record is to copy one retrieved
by a call to the <tt>tty-info</tt> procedure, then modify the copy as desired.
Note that the <tt>make-tty-info</tt> procedure does not take a parameter
to define the new record's control characters.<a name="call_footnote_Temp_15"></a><a href="#footnote_Temp_15"><sup><small>10</small></sup></a>
Instead, it simply returns a <tt>tty-info</tt> record whose control-character
string has all elements initialised to A<small>S</small><small>C</small><small>I</small><small>I</small> nul.
You may then install the special characters by assigning to the string.
Similarly, the control-character string in the record produced by
<tt>copy-tty-info</tt> does not share structure with the string in the record
being copied, so you may mutate it freely.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_756"></a></p>
<div align=left><tt>(tty-info <i>[fd/port/fname]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>tty-info-record</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
The <i>fd/port/fname</i> parameter is an integer file descriptor or 
Scheme I/O port opened on a terminal device, 
or a file-name for a terminal device; it defaults to the current input port.
This procedure returns a <tt>tty-info</tt> record describing the terminal's
current mode.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_758"></a></p>
<div align=left><tt>(set-tty-info/now <i>fd/port/fname info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>no-value</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_760"></a><div align=left><tt>(set-tty-info/drain <i>fd/port/fname info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>no-value</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_762"></a><div align=left><tt>(set-tty-info/flush <i>fd/port/fname info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>no-value</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
The <i>fd/port/fname</i> parameter is an integer file descriptor or 
Scheme I/O port opened on a terminal device, 
or a file-name for a terminal device.
The procedure chosen determines when and how the terminal's mode is altered:
<div align=center><table><tr><td>

<table border=1><tr><td valign=top >Procedure </td><td valign=top >Meaning </td></tr>
<tr><td valign=top ><tt>set-tty-info/now</tt>   </td><td valign=top >Make change immediately. </td></tr>
<tr><td valign=top ><tt>set-tty-info/drain</tt> </td><td valign=top >Drain output, then change. </td></tr>
<tr><td valign=top ><tt>set-tty-info/flush</tt> </td><td valign=top >Drain output, flush input, then change. </td></tr>
<tr><td valign=top ></td></tr></table>
</td></tr></table></div>

<blockquote><i>Oops: </i> If I had defined these with the parameters in the reverse order,
I could have made <i>fd/port/fname</i> optional. Too late now.</blockquote>
</blockquote><p>
</p>
<a name="node_sec_3.12.5"></a>
<h3><a href="man-Z-H-1.html#node_toc_node_sec_3.12.5">3.12.5&nbsp;&nbsp;Other terminal-device procedures</a></h3><p></p>
<p></p>
<p></p>
<p><a name="node_idx_764"></a></p>
<div align=left><tt>(send-tty-break <i>[fd/port/fname duration]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>no-value</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
The <i>fd/port/fname</i> parameter is an integer file descriptor or 
Scheme I/O port opened on a terminal device, 
or a file-name for a terminal device; it defaults to the current output port.
Send a break signal to the designated terminal.
A break signal is a sequence of continuous zeros on the terminal's transmission
line.<p>
The <i>duration</i> argument determines the length of the break signal.
A zero value (the default) causes a break of between 
0.25 and 0.5 seconds to be sent;
other values determine a period in a manner that will depend upon local
community standards.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_766"></a></p>
<div align=left><tt>(drain-tty <i>[fd/port/fname]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>no-value</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
The <i>fd/port/fname</i> parameter is an integer file descriptor or 
Scheme I/O port opened on a terminal device, 
or a file-name for a terminal device; it defaults to the current output port.<p>
This procedure waits until all the output written to the
terminal device has been transmitted to the device.
If <i>fd/port/fname</i> is an output port with buffered I/O
enabled, then the port's buffered characters are flushed before
waiting for the device to drain.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_768"></a></p>
<div align=left><tt>(flush-tty/input <i>[fd/port/fname]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>no-value</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_770"></a><div align=left><tt>(flush-tty/output <i>[fd/port/fname]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>no-value</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_772"></a><div align=left><tt>(flush-tty/both <i>[fd/port/fname]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>no-value</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
The <i>fd/port/fname</i> parameter is an integer file descriptor or 
Scheme I/O port opened on a terminal device, 
or a file-name for a terminal device; it defaults to the current input
port (<tt>flush-tty/input</tt> and <tt>flush-tty/both</tt>),
or output port (<tt>flush-tty/output</tt>).<p>
These procedures discard the unread input chars or unwritten
output chars in the tty's kernel buffers. 
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_774"></a></p>
<div align=left><tt>(start-tty-output <i>[fd/port/fname]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>no-value</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_776"></a><div align=left><tt>(stop-tty-output <i>[fd/port/fname]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>no-value</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_778"></a><div align=left><tt>(start-tty-input <i>[fd/port/fname]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>no-value</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_780"></a><div align=left><tt>(stop-tty-input <i>[fd/port/fname]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>no-value</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
These procedures can be used to control a terminal's input and output flow.
The <i>fd/port/fname</i> parameter is an integer file descriptor or 
Scheme I/O port opened on a terminal device, 
or a file-name for a terminal device; it defaults to the current input
or output port.<p>
The <tt>stop-tty-output</tt> and <tt>start-tty-output</tt> procedures suspend
and resume output from a terminal device.
The <tt>stop-tty-input</tt> and <tt>start-tty-input</tt> procedures transmit
the special STOP and START characters to the terminal with the intention
of stopping and starting terminal input flow.
</p>
</blockquote><p>
</p>
<p>
</p>
<a name="node_sec_3.12.6"></a>
<h3><a href="man-Z-H-1.html#node_toc_node_sec_3.12.6">3.12.6&nbsp;&nbsp;Control terminals, sessions, and terminal process groups</a></h3><p></p>
<p></p>
<p></p>
<p><a name="node_idx_782"></a></p>
<div align=left><tt>(open-control-tty <i>tty-name [flags]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>port</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
This procedure opens terminal device <i>tty-name</i> as the process'
control terminal 
(see the <tt>termios</tt> man page for more information on control terminals).
The <i>tty-name</i> argument is a file-name such as <tt>/dev/ttya</tt>.
The <i>flags</i> argument is a value suitable as the second argument
to the <tt>open-file</tt> call; it defaults to <tt>open/read+write</tt>, causing
the terminal to be opened for both input and output.<p>
The port returned is an input port if the <i>flags</i> permit it, 
otherwise an output port. 
R5RS/Scheme 48/scsh do not have input/output ports,
so it's one or the other. 
However, you can get both read and write ports open on a terminal
by opening it read/write, taking the result input port,
and duping it to an output port with <tt>dup-&gt;outport</tt>.</p>
<p>
This procedure guarantees to make the opened terminal the
process' control terminal only if the process does not have
an assigned control terminal at the time of the call.
If the scsh process already has a control terminal, the results are undefined.</p>
<p>
To arrange for the process to have no control terminal prior to calling
this procedure, use the <tt>become-session-leader</tt> procedure.</p>
<p>
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_784"></a></p>
<div align=left><tt>(become-session-leader<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
This is the C <tt>setsid()</tt> call.
P<small>O</small><small>S</small><small>I</small><small>X</small> job-control has a three-level hierarchy:
session/process-group/process. 
Every session has an associated control terminal.
This procedure places the current process into a brand new session,
and disassociates the process from any previous control terminal.
You may subsequently use <tt>open-control-tty</tt> to open a new control
terminal.<p>
It is an error to call this procedure if the current process is already
a process-group leader.
One way to guarantee this is not the case is only to call this procedure
after forking.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_786"></a></p>
<div align=left><tt>(tty-process-group <i>fd/port/fname</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_788"></a><div align=left><tt>(set-tty-process-group <i>fd/port/fname pgrp</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
This pair of procedures gets and sets the process group of a given
terminal.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_790"></a></p>
<div align=left><tt>(control-tty-file-name<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Return the file-name of the process' control tty.
On every version of Unix of which we are aware, this is just the string
<tt>&quot;/dev/tty&quot;</tt>.
However, this procedure uses the official Posix interface, so it is more
portable than simply using a constant string.
</blockquote><p>
</p>
<a name="node_sec_3.12.7"></a>
<h3><a href="man-Z-H-1.html#node_toc_node_sec_3.12.7">3.12.7&nbsp;&nbsp;Pseudo-terminals</a></h3><p>Scsh implements an interface to Berkeley-style pseudo-terminals.</p>
<p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_792"></a></p>
<div align=left><tt>(fork-pty-session <i>thunk</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>[process pty-in pty-out tty-name]</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
This procedure gives a convenient high-level interface to pseudo-terminals.
It first allocates a pty/tty pair of devices, and then forks a child
to execute procedure <i>thunk</i>.
In the child process
<ul>
<li><p>Stdio and the current I/O ports are bound to the terminal device.
</p>
<li><p>The child is placed in its own, new session
(see <tt>become-session-leader</tt>).
</p>
<li><p>The terminal device becomes the new session's controlling terminal
(see <tt>open-control-tty</tt>).
</p>
<li><p>The <tt>(error-output-port)</tt> is unbuffered.
</p>
</ul><p></p>
<p>
The <tt>fork-pty-session</tt> procedure returns four values:
the child's process object, two ports open on the controlling pty device,
and the name of the child's corresponding terminal device.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_794"></a></p>
<div align=left><tt>(open-pty<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>pty-inport tty-name</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
This procedure finds a free pty/tty pair, and opens the pty device
with read/write access.
It returns a port on the pty, 
and the name of the corresponding terminal device.<p>
The port returned is an input port -- Scheme doesn't allow input/output
ports.
However, you can easily use <tt>(dup-&gt;outport <i>pty-inport</i>)</tt>
to produce a matching output port.
You may wish to turn off I/O buffering for this output port.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_796"></a></p>
<div align=left><tt>(pty-name-&gt;tty-name <i>pty-name</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>tty-name</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_798"></a><div align=left><tt>(tty-name-&gt;pty-name <i>tty-name</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>pty-name</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
These two procedures map between corresponding terminal and pty controller
names.
For example,
<blockquote><tt><br>
(pty-name-&gt;tty-name&nbsp;&quot;/dev/ptyq3&quot;)&nbsp;==&gt;&nbsp;&nbsp;&quot;/dev/ttyq3&quot;<br>
(tty-name-&gt;pty-name&nbsp;&quot;/dev/ttyrc&quot;)&nbsp;==&gt;&nbsp;&nbsp;&quot;/dev/ptyrc&quot;</tt></blockquote><p>
</p>
<blockquote><i>Remark: </i> This is rather Berkeley-specific. SVR4 ptys are rare enough that
I've no real idea if it generalises across the Unix gap. Experts
are invited to advise. Users feel free to not worry -- the predominance
of current popular Unix systems use Berkeley ptys.</blockquote>
</blockquote><p>
<a name="node_idx_800"></a></p>
<div align=left><tt>(make-pty-generator<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>procedure</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
This procedure returns a generator of candidate pty names.
Each time the returned procedure is called, it produces a
new candidate.
Software that wishes to search through the set of available ptys
can use a pty generator to iterate over them.
After producing all the possible ptys, a generator returns <tt>#f</tt>
every time it is called.
Example:
<blockquote><tt><br>
(define&nbsp;pg&nbsp;(make-pty-generator))<br>
(pg)&nbsp;==&gt;&nbsp;&nbsp;&quot;/dev/ptyp0&quot;<br>
(pg)&nbsp;==&gt;&nbsp;&nbsp;&quot;/dev/ptyp1&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="man-Z-G-D-1.gif" border="0" alt="[man-Z-G-D-1.gif]"><br>
(pg)&nbsp;==&gt;&nbsp;&nbsp;&quot;/dev/ptyqe&quot;<br>
(pg)&nbsp;==&gt;&nbsp;&nbsp;&quot;/dev/ptyqf&quot;&nbsp;&nbsp;&nbsp;&nbsp;<i>(Last&nbsp;one)</i><br>
(pg)&nbsp;==&gt;&nbsp;&nbsp;<tt>#f</tt><br>
(pg)&nbsp;==&gt;&nbsp;&nbsp;<tt>#f</tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="man-Z-G-D-1.gif" border="0" alt="[man-Z-G-D-1.gif]"></tt></blockquote>
</blockquote><p>
</p>
<p>
</p>
<p></p>
<hr>
<p></p>
<a name="node_tbl_Temp_16"></a>
<div class=table align=center><table width=100%><tr><td align=center>
<div align=center><table><tr><td>

<table border=1><tr><td valign=top >Scsh </td><td valign=top >C </td><td valign=top >Typical char </td></tr>
<tr><td valign=top >P<small>O</small><small>S</small><small>I</small><small>X</small> </td><td valign=top ></td><td valign=top ></td></tr>
<tr><td valign=top ><a name="node_idx_802"></a><tt>ttychar/delete-char</tt>       </td><td valign=top ><tt>ERASE</tt>    </td><td valign=top >del </td></tr>
<tr><td valign=top ><a name="node_idx_804"></a><tt>ttychar/delete-line</tt>       </td><td valign=top ><tt>KILL</tt>     </td><td valign=top ><code class=verbatim>^U</code> </td></tr>
<tr><td valign=top ><a name="node_idx_806"></a><tt>ttychar/eof</tt>               </td><td valign=top ><tt>EOF</tt>      </td><td valign=top ><code class=verbatim>^D</code> </td></tr>
<tr><td valign=top ><a name="node_idx_808"></a><tt>ttychar/eol</tt>               </td><td valign=top ><tt>EOL</tt>      </td><td valign=top ></td></tr>
<tr><td valign=top ><a name="node_idx_810"></a><tt>ttychar/interrupt</tt>         </td><td valign=top ><tt>INTR</tt>     </td><td valign=top ><code class=verbatim>^C</code> </td></tr>
<tr><td valign=top ><a name="node_idx_812"></a><tt>ttychar/quit</tt>              </td><td valign=top ><tt>QUIT</tt>     </td><td valign=top ><code class=verbatim>^\</code> </td></tr>
<tr><td valign=top ><a name="node_idx_814"></a><tt>ttychar/suspend</tt>           </td><td valign=top ><tt>SUSP</tt>     </td><td valign=top ><code class=verbatim>^Z</code> </td></tr>
<tr><td valign=top ><a name="node_idx_816"></a><tt>ttychar/start</tt>             </td><td valign=top ><tt>START</tt>    </td><td valign=top ><code class=verbatim>^Q</code> </td></tr>
<tr><td valign=top ><a name="node_idx_818"></a><tt>ttychar/stop</tt>              </td><td valign=top ><tt>STOP</tt>     </td><td valign=top ><code class=verbatim>^S</code> </td></tr>
<tr><td valign=top ><p>
SVR4 and 4.3+BSD </p>
</td><td valign=top ></td><td valign=top ></td></tr>
<tr><td valign=top ><a name="node_idx_820"></a><tt>ttychar/delayed-suspend</tt>   </td><td valign=top ><tt>DSUSP</tt>    </td><td valign=top ><code class=verbatim>^Y</code> </td></tr>
<tr><td valign=top ><a name="node_idx_822"></a><tt>ttychar/delete-word</tt>       </td><td valign=top ><tt>WERASE</tt>   </td><td valign=top ><code class=verbatim>^W</code> </td></tr>
<tr><td valign=top ><a name="node_idx_824"></a><tt>ttychar/discard</tt>           </td><td valign=top ><tt>DISCARD</tt>  </td><td valign=top ><code class=verbatim>^O</code> </td></tr>
<tr><td valign=top ><a name="node_idx_826"></a><tt>ttychar/eol2</tt>              </td><td valign=top ><tt>EOL2</tt>     </td><td valign=top ></td></tr>
<tr><td valign=top ><a name="node_idx_828"></a><tt>ttychar/literal-next</tt>      </td><td valign=top ><tt>LNEXT</tt>    </td><td valign=top ><code class=verbatim>^V</code> </td></tr>
<tr><td valign=top ><a name="node_idx_830"></a><tt>ttychar/reprint</tt>           </td><td valign=top ><tt>REPRINT</tt>  </td><td valign=top ><code class=verbatim>^R</code> </td></tr>
<tr><td valign=top ><p>
4.3+BSD </p>
</td><td valign=top ></td><td valign=top ></td></tr>
<tr><td valign=top ><a name="node_idx_832"></a><tt>ttychar/status</tt>            </td><td valign=top ><tt>STATUS</tt>   </td><td valign=top ><code class=verbatim>^T</code> </td></tr>
<tr><td valign=top ></td></tr></table>
</td></tr></table></div>

</td></tr>
<tr><td align=center><b>Table 4:</b>&nbsp;&nbsp;Indices into the <tt>tty-info</tt> record's 
<i>control-chars</i> string,
and the character traditionally found at each index.
Only the indices for the P<small>O</small><small>S</small><small>I</small><small>X</small> entries are guaranteed to
be non-<tt>#f</tt>.</td></tr>
<tr><td>

</td></tr></table></div><p></p>
<hr>
<p></p>
<p></p>
<p>
</p>
<p></p>
<hr>
<p></p>
<a name="node_tbl_Temp_17"></a>
<div class=table align=center><table width=100%><tr><td align=center>
<div align=center><table><tr><td>
<table border=1><tr><td valign=top >Scsh </td><td valign=top >C </td><td valign=top >Meaning </td></tr>
<tr><td valign=top >P<small>O</small><small>S</small><small>I</small><small>X</small></td><td valign=top ></td><td valign=top ></td></tr>
<tr><td valign=top ><a name="node_idx_834"></a><tt>ttyin/check-parity</tt>
</td><td valign=top ><tt>INPCK</tt>    </td><td valign=top >Check parity. </td></tr>
<tr><td valign=top ><a name="node_idx_836"></a><tt>ttyin/ignore-bad-parity-chars</tt>
</td><td valign=top ><tt>IGNPAR</tt>   </td><td valign=top >Ignore chars with parity errors. </td></tr>
<tr><td valign=top ><a name="node_idx_838"></a><tt>ttyin/mark-parity-errors</tt>
</td><td valign=top ><tt>PARMRK</tt>   </td><td valign=top >Insert chars to mark parity errors.</td></tr>
<tr><td valign=top ><a name="node_idx_840"></a><tt>ttyin/ignore-break</tt>
</td><td valign=top ><tt>IGNBRK</tt>   </td><td valign=top >Ignore breaks. </td></tr>
<tr><td valign=top ><a name="node_idx_842"></a><tt>ttyin/interrupt-on-break</tt>
</td><td valign=top ><tt>BRKINT</tt>   </td><td valign=top >Signal on breaks. </td></tr>
<tr><td valign=top ><a name="node_idx_844"></a><tt>ttyin/7bits</tt>
</td><td valign=top ><tt>ISTRIP</tt>   </td><td valign=top >Strip char to seven bits. </td></tr>
<tr><td valign=top ><a name="node_idx_846"></a><tt>ttyin/cr-&gt;nl</tt>
</td><td valign=top ><tt>ICRNL</tt>    </td><td valign=top >Map carriage-return to newline. </td></tr>
<tr><td valign=top ><a name="node_idx_848"></a><tt>ttyin/ignore-cr</tt>
</td><td valign=top ><tt>IGNCR</tt>    </td><td valign=top >Ignore carriage-returns. </td></tr>
<tr><td valign=top ><a name="node_idx_850"></a><tt>ttyin/nl-&gt;cr</tt>
</td><td valign=top ><tt>INLCR</tt>    </td><td valign=top >Map newline to carriage-return. </td></tr>
<tr><td valign=top ><a name="node_idx_852"></a><tt>ttyin/input-flow-ctl</tt>
</td><td valign=top ><tt>IXOFF</tt>    </td><td valign=top >Enable input flow control. </td></tr>
<tr><td valign=top ><a name="node_idx_854"></a><tt>ttyin/output-flow-ctl</tt>
</td><td valign=top ><tt>IXON</tt>     </td><td valign=top >Enable output flow control. </td></tr>
<tr><td valign=top ><p>
SVR4 and 4.3+BSD </p>
</td><td valign=top ></td><td valign=top ></td></tr>
<tr><td valign=top ><a name="node_idx_856"></a><tt>ttyin/xon-any</tt>             </td><td valign=top ><tt>IXANY</tt> </td><td valign=top >Any char restarts after stop. </td></tr>
<tr><td valign=top ><a name="node_idx_858"></a><tt>ttyin/beep-on-overflow</tt>    </td><td valign=top ><tt>IMAXBEL</tt> </td><td valign=top >Ring bell when queue full. </td></tr>
<tr><td valign=top ><p>
SVR4 </p>
</td><td valign=top ></td><td valign=top ></td></tr>
<tr><td valign=top ><a name="node_idx_860"></a><tt>ttyin/lowercase</tt>           </td><td valign=top ><tt>IUCLC</tt> </td><td valign=top >Map upper case to lower case. </td></tr>
<tr><td valign=top ></td></tr></table>
</td></tr></table></div>

</td></tr>
<tr><td align=center><b>Table 5:</b>&nbsp;&nbsp;Input-flags. These are the named flags for the <tt>tty-info</tt> 
record's <i>input-flags</i> field.
These flags generally control the processing of input chars.
Only the P<small>O</small><small>S</small><small>I</small><small>X</small> entries are guaranteed to be non-<tt>#f</tt>.
</td></tr>
<tr><td>

</td></tr></table></div><p></p>
<hr>
<p></p>
<p></p>
<p>
</p>
<p></p>
<hr>
<p></p>
<a name="node_tbl_Temp_18"></a>
<div class=table align=center><table width=100%><tr><td align=center>
<div align=center><table><tr><td>
<table border=1><tr><td valign=top >Scsh </td><td valign=top >C </td><td valign=top >Meaning </td></tr>
<tr><td valign=top ><p>
3|l|P<small>O</small><small>S</small><small>I</small><small>X</small> </td></tr>
<tr><td valign=top ><a name="node_idx_862"></a><tt>ttyout/enable</tt>  </p>
</td><td valign=top ><tt>OPOST</tt> </td><td valign=top >Enable output processing. </td></tr>
<tr><td valign=top ><p>
3|l|SVR4 and 4.3+BSD </td></tr>
<tr><td valign=top ><a name="node_idx_864"></a><tt>ttyout/nl-&gt;crnl</tt>   </p>
</td><td valign=top ><tt>ONLCR</tt> </td><td valign=top >Map nl to cr-nl. </td></tr>
<tr><td valign=top ><p>
3|l|4.3+BSD </td></tr>
<tr><td valign=top ><a name="node_idx_866"></a><tt>ttyout/discard-eot</tt>    </p>
</td><td valign=top ><tt>ONOEOT</tt>       </td><td valign=top >Discard EOT chars. </td></tr>
<tr><td valign=top ><a name="node_idx_868"></a><tt>ttyout/expand-tabs</tt>    </td><td valign=top ><tt>OXTABS</tt><a name="call_footnote_Temp_19"></a><a href="#footnote_Temp_19"><sup><small>11</small></sup></a>
</td><td valign=top >Expand tabs. </td></tr>
<tr><td valign=top ><p>
3|l|SVR4 </td></tr>
<tr><td valign=top ><a name="node_idx_870"></a><tt>ttyout/cr-&gt;nl</tt>             </p>
</td><td valign=top ><tt>OCRNL</tt> </td><td valign=top >Map cr to nl. </td></tr>
<tr><td valign=top ><a name="node_idx_872"></a><tt>ttyout/nl-does-cr</tt>         </td><td valign=top ><tt>ONLRET</tt></td><td valign=top >Nl performs cr as well. </td></tr>
<tr><td valign=top ><a name="node_idx_874"></a><tt>ttyout/no-col0-cr</tt>         </td><td valign=top ><tt>ONOCR</tt> </td><td valign=top >No cr output in column 0. </td></tr>
<tr><td valign=top ><a name="node_idx_876"></a><tt>ttyout/delay-w/fill-char</tt>  </td><td valign=top ><tt>OFILL</tt> </td><td valign=top >Send fill char to delay. </td></tr>
<tr><td valign=top ><a name="node_idx_878"></a><tt>ttyout/fill-w/del</tt>         </td><td valign=top ><tt>OFDEL</tt> </td><td valign=top >Fill char is A<small>S</small><small>C</small><small>I</small><small>I</small> DEL. </td></tr>
<tr><td valign=top ><a name="node_idx_880"></a><tt>ttyout/uppercase</tt>          </td><td valign=top ><tt>OLCUC</tt> </td><td valign=top >Map lower to upper case. </td></tr>
<tr><td valign=top ></td></tr></table>
</td></tr></table></div>

</td></tr>
<tr><td align=center><b>Table 6:</b>&nbsp;&nbsp;Output-flags. These are the named flags for the <tt>tty-info</tt>
record's <i>output-flags</i> field.
These flags generally control the processing of output chars.
Only the P<small>O</small><small>S</small><small>I</small><small>X</small> entries are guaranteed to be non-<tt>#f</tt>.</td></tr>
<tr><td>

</td></tr></table></div><p></p>
<hr>
<p></p>
<p></p>
<p>
</p>
<p></p>
<hr>
<p></p>
<a name="node_tbl_Temp_20"></a>
<div class=table align=center><table width=100%><tr><td align=center>
<table border=1><tr><td valign=top >
</td><td valign=top >Value </td><td valign=top >Comment </td></tr>
<tr><td valign=top >
Backspace delay       </td><td valign=top ><a name="node_idx_882"></a><tt>ttyout/bs-delay</tt>         </td><td valign=top >Bit-field mask </td></tr>
<tr><td valign=top ></td><td valign=top ><a name="node_idx_884"></a><tt>ttyout/bs-delay0</tt>        </td><td valign=top ></td></tr>
<tr><td valign=top ></td><td valign=top ><a name="node_idx_886"></a><tt>ttyout/bs-delay1</tt>        </td><td valign=top ></td></tr>
<tr><td valign=top ><p>

Carriage-return delay </p>
</td><td valign=top ><a name="node_idx_888"></a><tt>ttyout/cr-delay</tt>         </td><td valign=top >Bit-field mask </td></tr>
<tr><td valign=top ></td><td valign=top ><a name="node_idx_890"></a><tt>ttyout/cr-delay0</tt>        </td><td valign=top ></td></tr>
<tr><td valign=top ></td><td valign=top ><a name="node_idx_892"></a><tt>ttyout/cr-delay1</tt>        </td><td valign=top ></td></tr>
<tr><td valign=top ></td><td valign=top ><a name="node_idx_894"></a><tt>ttyout/cr-delay2</tt>        </td><td valign=top ></td></tr>
<tr><td valign=top ></td><td valign=top ><a name="node_idx_896"></a><tt>ttyout/cr-delay3</tt>        </td><td valign=top ></td></tr>
<tr><td valign=top ><p>

Form-feed delay       </p>
</td><td valign=top ><a name="node_idx_898"></a><tt>ttyout/ff-delay</tt>         </td><td valign=top >Bit-field mask </td></tr>
<tr><td valign=top ></td><td valign=top ><a name="node_idx_900"></a><tt>ttyout/ff-delay0</tt>        </td><td valign=top ></td></tr>
<tr><td valign=top ></td><td valign=top ><a name="node_idx_902"></a><tt>ttyout/ff-delay1</tt>        </td><td valign=top ></td></tr>
<tr><td valign=top ><p>

Horizontal-tab delay  </p>
</td><td valign=top ><a name="node_idx_904"></a><tt>ttyout/tab-delay</tt>        </td><td valign=top >Bit-field mask </td></tr>
<tr><td valign=top ></td><td valign=top ><a name="node_idx_906"></a><tt>ttyout/tab-delay0</tt>       </td><td valign=top ></td></tr>
<tr><td valign=top ></td><td valign=top ><a name="node_idx_908"></a><tt>ttyout/tab-delay1</tt>       </td><td valign=top ></td></tr>
<tr><td valign=top ></td><td valign=top ><a name="node_idx_910"></a><tt>ttyout/tab-delay2</tt>       </td><td valign=top ></td></tr>
<tr><td valign=top ></td><td valign=top ><a name="node_idx_912"></a><tt>ttyout/tab-delayx</tt>       </td><td valign=top >Expand tabs </td></tr>
<tr><td valign=top ><p>

Newline delay         </p>
</td><td valign=top ><a name="node_idx_914"></a><tt>ttyout/nl-delay</tt>         </td><td valign=top >Bit-field mask </td></tr>
<tr><td valign=top ></td><td valign=top ><a name="node_idx_916"></a><tt>ttyout/nl-delay0</tt>        </td><td valign=top ></td></tr>
<tr><td valign=top ></td><td valign=top ><a name="node_idx_918"></a><tt>ttyout/nl-delay1</tt>        </td><td valign=top ></td></tr>
<tr><td valign=top ><p>

Vertical tab delay    </p>
</td><td valign=top ><a name="node_idx_920"></a><tt>ttyout/vtab-delay</tt>       </td><td valign=top >Bit-field mask </td></tr>
<tr><td valign=top ></td><td valign=top ><a name="node_idx_922"></a><tt>ttyout/vtab-delay0</tt>      </td><td valign=top ></td></tr>
<tr><td valign=top ></td><td valign=top ><a name="node_idx_924"></a><tt>ttyout/vtab-delay1</tt>      </td><td valign=top ></td></tr>
<tr><td valign=top ><p>

All                   </p>
</td><td valign=top ><a name="node_idx_926"></a><tt>ttyout/all-delay</tt>  </td><td valign=top >Total bit-field mask </td></tr>
<tr><td valign=top >
</td></tr></table><p>
</p>
</td></tr>
<tr><td align=center><b>Table 7:</b>&nbsp;&nbsp;Delay constants. These are the named flags for the
<tt>tty-info</tt> record's <i>output-flags</i> field.
These flags control the output delays associated with printing
special characters.
They are non-P<small>O</small><small>S</small><small>I</small><small>X</small>, and have non-<tt>#f</tt> values
only on SVR4 systems.</td></tr>
<tr><td>

</td></tr></table></div><p></p>
<hr>
<p></p>
<p></p>
<p>
</p>
<p></p>
<hr>
<p></p>
<a name="node_tbl_Temp_21"></a>
<div class=table align=center><table width=100%><tr><td align=center>
<div align=center><table><tr><td>
<table border=1><tr><td valign=top >Scsh </td><td valign=top >C </td><td valign=top >Meaning </td></tr>
<tr><td valign=top ><p>
3|l|P<small>O</small><small>S</small><small>I</small><small>X</small> </td></tr>
<tr><td valign=top ><a name="node_idx_928"></a><tt>ttyc/char-size</tt>    </p>
</td><td valign=top ><tt>CSIZE</tt>    </td><td valign=top >Character size mask </td></tr>
<tr><td valign=top ><a name="node_idx_930"></a><tt>ttyc/char-size5</tt>   </td><td valign=top ><tt>CS5</tt>      </td><td valign=top >5 bits </td></tr>
<tr><td valign=top ><a name="node_idx_932"></a><tt>ttyc/char-size6</tt>   </td><td valign=top ><tt>CS6</tt>      </td><td valign=top >6 bits </td></tr>
<tr><td valign=top ><a name="node_idx_934"></a><tt>ttyc/char-size7</tt>   </td><td valign=top ><tt>CS7</tt>      </td><td valign=top >7 bits </td></tr>
<tr><td valign=top ><a name="node_idx_936"></a><tt>ttyc/char-size8</tt>   </td><td valign=top ><tt>CS8</tt>      </td><td valign=top >8 bits </td></tr>
<tr><td valign=top ><a name="node_idx_938"></a><tt>ttyc/enable-parity</tt></td><td valign=top ><tt>PARENB</tt>   </td><td valign=top >Generate and detect parity. </td></tr>
<tr><td valign=top ><a name="node_idx_940"></a><tt>ttyc/odd-parity</tt>   </td><td valign=top ><tt>PARODD</tt>   </td><td valign=top >Odd parity. </td></tr>
<tr><td valign=top ><a name="node_idx_942"></a><tt>ttyc/enable-read</tt>  </td><td valign=top ><tt>CREAD</tt>    </td><td valign=top >Enable reception of chars. </td></tr>
<tr><td valign=top ><a name="node_idx_944"></a><tt>ttyc/hup-on-close</tt> </td><td valign=top ><tt>HUPCL</tt>    </td><td valign=top >Hang up on last close. </td></tr>
<tr><td valign=top ><a name="node_idx_946"></a><tt>ttyc/no-modem-sync</tt></td><td valign=top ><tt>LOCAL</tt>    </td><td valign=top >Ignore modem lines. </td></tr>
<tr><td valign=top ><a name="node_idx_948"></a><tt>ttyc/2-stop-bits</tt>  </td><td valign=top ><tt>CSTOPB</tt>   </td><td valign=top >Send two stop bits. </td></tr>
<tr><td valign=top ><p>
3|l|4.3+BSD </td></tr>
<tr><td valign=top ><a name="node_idx_950"></a><tt>ttyc/ignore-flags</tt>         </p>
</td><td valign=top ><tt>CIGNORE</tt>  </td><td valign=top >Ignore control flags. </td></tr>
<tr><td valign=top ><a name="node_idx_952"></a><tt>ttyc/CTS-output-flow-ctl</tt>  </td><td valign=top ><code class=verbatim>CCTS_OFLOW</code> </td><td valign=top >CTS flow control of output </td></tr>
<tr><td valign=top ><a name="node_idx_954"></a><tt>ttyc/RTS-input-flow-ctl</tt>   </td><td valign=top ><code class=verbatim>CRTS_IFLOW</code> </td><td valign=top >RTS flow control of input </td></tr>
<tr><td valign=top ><a name="node_idx_956"></a><tt>ttyc/carrier-flow-ctl</tt>     </td><td valign=top ><tt>MDMBUF</tt> </td><td valign=top ></td></tr>
<tr><td valign=top ></td></tr></table>
</td></tr></table></div>
<p>
</p>
</td></tr>
<tr><td align=center><b>Table 8:</b>&nbsp;&nbsp;Control-flags. These are the named flags for the <tt>tty-info</tt>
record's <i>control-flags</i> field.
These flags generally control the details of the terminal's
serial line.
Only the P<small>O</small><small>S</small><small>I</small><small>X</small> entries are guaranteed to be non-<tt>#f</tt>.</td></tr>
<tr><td>

</td></tr></table></div><p></p>
<hr>
<p></p>
<p></p>
<p>
</p>
<p></p>
<hr>
<p></p>
<a name="node_tbl_Temp_22"></a>
<div class=table align=center><table width=100%><tr><td align=center>
<div align=center><table><tr><td>
<table border=1><tr><td valign=top >Scsh </td><td valign=top >C </td><td valign=top >Meaning </td></tr>
<tr><td valign=top ><p>
3|l|P<small>O</small><small>S</small><small>I</small><small>X</small> </td></tr>
<tr><td valign=top ><a name="node_idx_958"></a><tt>ttyl/canonical</tt>    </p>
</td><td valign=top ><tt>ICANON</tt>    </td><td valign=top >Canonical input processing. </td></tr>
<tr><td valign=top ><a name="node_idx_960"></a><tt>ttyl/echo</tt>         </td><td valign=top ><tt>ECHO</tt>      </td><td valign=top >Enable echoing. </td></tr>
<tr><td valign=top ><a name="node_idx_962"></a><tt>ttyl/echo-delete-line</tt> </td><td valign=top ><tt>ECHOK</tt>   </td><td valign=top >Echo newline after line kill. </td></tr>
<tr><td valign=top ><a name="node_idx_964"></a><tt>ttyl/echo-nl</tt>      </td><td valign=top ><tt>ECHONL</tt>    </td><td valign=top >Echo newline even if echo is off. </td></tr>
<tr><td valign=top ><a name="node_idx_966"></a><tt>ttyl/visual-delete</tt></td><td valign=top ><tt>ECHOE</tt>     </td><td valign=top >Visually erase chars. </td></tr>
<tr><td valign=top ><a name="node_idx_968"></a><tt>ttyl/enable-signals</tt> </td><td valign=top ><tt>ISIG</tt>    </td><td valign=top >Enable <code class=verbatim>^</code>C, <code class=verbatim>^</code>Z signalling. </td></tr>
<tr><td valign=top ><a name="node_idx_970"></a><tt>ttyl/extended</tt>     </td><td valign=top ><tt>IEXTEN</tt>    </td><td valign=top >Enable extensions. </td></tr>
<tr><td valign=top ><a name="node_idx_972"></a><tt>ttyl/no-flush-on-interrupt</tt>
</td><td valign=top ><tt>NOFLSH</tt>    </td><td valign=top >Don't flush after interrupt. </td></tr>
<tr><td valign=top ><a name="node_idx_974"></a><tt>ttyl/ttou-signal</tt>  </td><td valign=top ><tt>ITOSTOP</tt>   </td><td valign=top ><tt>SIGTTOU</tt> on background output. </td></tr>
<tr><td valign=top ><p>
3|l|SVR4 and 4.3+BSD </td></tr>
<tr><td valign=top ><a name="node_idx_976"></a><tt>ttyl/echo-ctl</tt>             </p>
</td><td valign=top ><tt>ECHOCTL</tt>  
</td><td valign=top >Echo control chars as ``<code class=verbatim>^X</code>''. </td></tr>
<tr><td valign=top ><a name="node_idx_978"></a><tt>ttyl/flush-output</tt>         </td><td valign=top ><tt>FLUSHO</tt>   </td><td valign=top >Output is being flushed. </td></tr>
<tr><td valign=top ><a name="node_idx_980"></a><tt>ttyl/hardcopy-delete</tt>      </td><td valign=top ><tt>ECHOPRT</tt>  </td><td valign=top >Visual erase for hardcopy. </td></tr>
<tr><td valign=top ><a name="node_idx_982"></a><tt>ttyl/reprint-unread-chars</tt> </td><td valign=top ><tt>PENDIN</tt>   </td><td valign=top >Retype pending input. </td></tr>
<tr><td valign=top ><a name="node_idx_984"></a><tt>ttyl/visual-delete-line</tt>   </td><td valign=top ><tt>ECHOKE</tt>   </td><td valign=top >Visually erase a line-kill. </td></tr>
<tr><td valign=top ><p>
3|l|4.3+BSD </td></tr>
<tr><td valign=top ><a name="node_idx_986"></a><tt>ttyl/alt-delete-word</tt>      </p>
</td><td valign=top ><tt>ALTWERASE</tt>  </td><td valign=top >Alternate word erase algorithm </td></tr>
<tr><td valign=top ><a name="node_idx_988"></a><tt>ttyl/no-kernel-status</tt>     </td><td valign=top ><tt>NOKERNINFO</tt> </td><td valign=top >No kernel status on <code class=verbatim>^T</code>. </td></tr>
<tr><td valign=top ><p>
3|l|SVR4 </td></tr>
<tr><td valign=top ><a name="node_idx_990"></a><tt>ttyl/case-map</tt>     </p>
</td><td valign=top ><tt>XCASE</tt> </td><td valign=top >Canonical case presentation </td></tr>
<tr><td valign=top ></td></tr></table>
</td></tr></table></div>
<p>
</p>
</td></tr>
<tr><td align=center><b>Table 9:</b>&nbsp;&nbsp;Local-flags. These are the named flags for the <tt>tty-info</tt>
record's <i>local-flags</i> field.
These flags generally control the details of the line-editting
user interface.
Only the P<small>O</small><small>S</small><small>I</small><small>X</small> entries are guaranteed to be non-<tt>#f</tt>.</td></tr>
<tr><td>

</td></tr></table></div><p></p>
<hr>
<p></p>
<p>
</p>
<p>

</p>
<p>
</p>
<div class=footnoterule><hr></div><p></p>
<div class=footnote><p><a name="footnote_Temp_4"></a><a href="#call_footnote_Temp_4"><sup><small>3</small></sup></a> Why not <tt>move-&gt;fdes</tt>? 
Because the current output port and error port
might be the same port.</p>
<p><a name="footnote_Temp_6"></a><a href="#call_footnote_Temp_6"><sup><small>4</small></sup></a> But see the note above</p>
<p><a name="footnote_Temp_7"></a><a href="#call_footnote_Temp_7"><sup><small>5</small></sup></a> Why bother to mention such a silly possibility?
Because that is what sh does.</p>
<p><a name="footnote_Temp_9"></a><a href="#call_footnote_Temp_9"><sup><small>6</small></sup></a> Also bound to Scheme 48 interrupt 
<a name="node_idx_540"></a><tt>interrupt/alarm</tt>.</p>
<p><a name="footnote_Temp_10"></a><a href="#call_footnote_Temp_10"><sup><small>7</small></sup></a> Also bound to Scheme 48 interrupt 
<a name="node_idx_546"></a><tt>interrupt/keyboard</tt>.</p>
<p><a name="footnote_Temp_12"></a><a href="#call_footnote_Temp_12"><sup><small>8</small></sup></a> Physics pedants please note:
The scsh authors live in a Newtonian universe. We disclaim responsibility
for calculations performed in non-ANSI standard light-cones.</p>
<p><a name="footnote_Temp_14"></a><a href="#call_footnote_Temp_14"><sup><small>9</small></sup></a> <tt>...</tt>and hope the individual list elements 
don't contain colons themselves.</p>
<p><a name="footnote_Temp_15"></a><a href="#call_footnote_Temp_15"><sup><small>10</small></sup></a> 
Why? Because the length of the string varies from Unix to Unix.
For example, the word-erase control character (typically control-w)
is provided by most Unixes, but not part of the P<small>O</small><small>S</small><small>I</small><small>X</small> spec.</p>
<p><a name="footnote_Temp_19"></a><a href="#call_footnote_Temp_19"><sup><small>11</small></sup></a> 
Note this is distinct from the SVR4-equivalent
<tt>ttyout/tab-delayx</tt> flag defined in 
table&nbsp;<a href="#node_tbl_Temp_20">7</a>.</p>
</div>
<div align=right class=navigation><i>[Go to <span><a href="man.html">first</a>, <a href="man-Z-H-3.html">previous</a></span><span>, <a href="man-Z-H-5.html">next</a></span> page<span>; &nbsp;&nbsp;</span><span><a href="man-Z-H-1.html#node_toc_start">contents</a></span><span><span>; &nbsp;&nbsp;</span><a href="man-Z-H-13.html#node_index_start">index</a></span>]</i></div><p></p>
</body>
</html>
